\documentclass[conference]{IEEEtran}
% \documentclass{article}

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{bussproofs,proof}

\usepackage{array}

\usepackage{xcolor,latexsym,mathtools}

\usepackage{enumitem}
\usepackage{graphicx}

% \usepackage{glossaries}


% \usepackage[page]{appendix}

\newcommand{\projectname}{Treehehe}

\begin{document}

\title{Treehehe: An interactive visualization of proof trees
}

\author{\IEEEauthorblockN{Chelsea Battell}
\IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
\textit{University of Ottawa}\\
Ottawa, Canada \\
cbattell@uottawa.ca}
}

% \author{\IEEEauthorblockN{1\textsuperscript{st} Chelsea Battell}
% \IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
% \textit{University of Ottawa}\\
% Ottawa, Canada \\
% cbattell@uottawa.ca}
% }

\maketitle

~\cite{infovis-ware}



% \begin{enumerate}
%     \item Introduction. \\
%         In one sentence, what’s the topic? Phrase it in a way that your reader will understand. If you’re writing a PhD thesis, your readers are the examiners – assume they are familiar with the general field of research, so you need to tell them specifically what topic your thesis addresses. Same advice works for scientific papers – the readers are the peer reviewers, and eventually others in your field interested in your research, so again they know the background work, but want to know specifically what topic your paper covers. \\

\newcommand{\sentenceone}{Proofs are commonly illustrated as trees to make the structure of the argument salient.}
%     \item State the problem you tackle. \\
%         What’s the key research question? Again, in one sentence. (Note: For a more general essay, I’d adjust this slightly to state the central question that you want to address) Remember, your first sentence introduced the overall topic, so now you can build on that, and focus on one key question within that topic. If you can’t summarize your thesis/paper/essay in one key question, then you don’t yet understand what you’re trying to write about. Keep working at this step until you have a single, concise (and understandable) question. \\

\newcommand{\sentencetwo}{A proof tree can be tedious to record and as a static object it does not realize its full potential as a route to comprehension of the proof it represents.}

%     \item Summarize (in one sentence) why nobody else has adequately answered the research question yet. \\
%         For a PhD thesis, you’ll have an entire chapter, covering what’s been done previously in the literature. Here you have to boil that down to one sentence. But remember, the trick is not to try and cover all the various ways in which people have tried and failed; the trick is to explain that there’s this one particular approach that nobody else tried yet (hint: it’s the thing that your research does). But here you’re phrasing it in such a way that it’s clear it’s a gap in the literature. So use a phrase such as “previous work has failed to address…”. (if you’re writing a more general essay, you still need to summarize the source material you’re drawing on, so you can pull the same trick – explain in a few words what the general message in the source material is, but expressed in terms of what’s missing) \\

\newcommand{\sentencethree}{There is literature on how to use visualization to support mathematics education and implementations of visual tools to walk through real analysis proofs~\cite{eproofs-alcock+wilkinson}, but none of this related work addresses the use of interactive proof trees or visualization for the proof theory community.}
%     \item Explain, in one sentence, how you tackled the research question. \\
%         What’s your big new idea? (Again for a more general essay, you might want to adapt this slightly: what’s the new perspective you have adopted? or: What’s your overall view on the question you introduced in step 2?) \\

\newcommand{\sentencefour}{To address this gap, we implement a tool for interacting with visual representations of proof trees to provide insight into the structure of the proof and its founding logic.}

%     \item In one sentence, how did you go about doing the research that follows from your big idea. \\
%         Did you run experiments? Build a piece of software? Carry out case studies? This is likely to be the longest sentence, especially if it’s a PhD thesis – after all you’re probably covering several years worth of research. But don’t overdo it – we’re still looking for a sentence that you could read aloud without having to stop for breath. Remember, the word ‘abstract’ means a summary of the main ideas with most of the detail left out. So feel free to omit detail! (For those of you who got this far and are still insisting on writing an essay rather than signing up for a PhD, this sentence is really an elaboration of sentence 4 – explore the consequences of your new perspective).

\newcommand{\sentencefive}{The proof visualization tool allows either open exploration of a proof or a directed walk-through, revealing supplementary information to serve as a form of discourse as the nodes are visited.}

%     \item As a single sentence, what’s the key impact of your research? \\
%         Here we’re not looking for the outcome of an experiment. We’re looking for a summary of the implications. What’s it all mean? Why should other people care? What can they do with your research. (Essay folks: all the same questions apply: what conclusions did you draw, and why would anyone care about them?)

\newcommand{\sentencesix}{This work provides a tool for gaining understanding of the structure of proofs, insight into the processes used in constructing such proofs, and also serves as a starting point for visualizations of proof trees in more complicated logics.}

% \end{enumerate}



\begin{abstract}
    \sentenceone{} \sentencetwo{} \sentencethree{} \sentencefour{} \sentencefive{} \sentencesix{}
\end{abstract}


\begin{IEEEkeywords}
    information visualization, visual analytics, proof visualization, proof tree, proof theory, mathematics education
\end{IEEEkeywords}


\section{Introduction}
\label{sec:intro}

% discuss application domain and problem area
% discussion of learning math and using visualizations... math education literature
% discussion of math education papers
% motivation

Proofs are naturally visual artifacts and an essential part of comprehension and advancement in logic. A proof is a logical argument providing evidence of the truth of some statement. It connects hypotheses and a goal through the application of rules that preserve truth. Typically these arguments have a tree structure; some inferences take multiple premises to derive a new statement, and the reasoning is not cyclical.

Proof trees are a common visual representation used to illustrate both the structure and details of a logical argument. There are many advantages to be found using proof trees: they are useful for learning about a logic through experimentation with writing proofs, they reveal structure in the proof that a linear proof presentation may obscure, they allow cognitive offloading when working through a challenging argument, and they can serve as a form of documentation. This work presents a tool to allow a user to explore proof trees and to gain insight in to the specific proof and the logic it is built from.

There are critical limitations in the use of proof trees in certain mediums. Even a straightforward, ``small'' proof tree can easily escape the bounds of a sheet of paper. Creating a digital version eliminates bounds on the size of the tree.

A proof tree is a static and declarative object, which requires some level of expertise to be parsed by the reader. In~\cite{repvisvis-duval}, Duval criticizes proof trees and mathematics visualizations, arguing that they don’t aid in operational or discursive comprehension. In this case he is speaking of static graphics and figures used when learning mathematics. To overcome this limitation of static proof trees, the user will be able to interact with the proof in two distinct ways.

The first will be in the form of a proof walk-through that will support operational comprehension by using colour to focus attention on the current inference in a proof and distinguish between previously seen inferences and future inferences. Past inferences will be coloured to be less visible. Another panel on the page will have information on how the focused node is derived to provide discourse. (adjust this argument and bring out content on colour and panel because it applies to both modes)

The second form of interaction will allow more free-form exploration of the proof tree. The user can click on any node to focus on it. (At this point, the rule used to infer this formula will be visible. Side conditions may be shown, as well as the substitutions for the rule schema variables.)

Before further discussion of the visualization tool, we will take a step back to review the logic concepts needed to understand how to use it. Next, the tool and expected user tasks will be described. Following an initial discussion of the tool and how to use it, we discuss the technologies used to implement it. InfoVis results used to motivate the design of the tool will be explored in the next section. Finally, we discuss benefits and limitations of the tool, future work, and finish with a conclusion reviewing what is presented here. We hope the reader will be left with an understanding of the motivation for and use of this tool and know how InfoVis techniques implemented here help users to learn about specific proofs and their founding logics (todo... make better).

TODO: expand on abstract? \\

TODO: articulate goals of project better? see talk \\

TODO: more math education literature? \\

In this information visualization tool, data elements are trees. More specifically, they are visual representations of proof trees. A proof tree is an object that shows the structure of a logical argument.

TODO: objective/goal/hopes for reader? \\


\section{Logic Background}
\label{sec:background}

Recall that the goal of the tool described in this report is to provide an interactive visualization of proof trees, which are structured logical arguments that are drawn following conventions. Before we can discuss the tool in detail, it is necessary to first review the application area. We will present the basics of logic, inference systems and proof trees from these systems. We will aim to discuss these preliminary concepts generally, while carrying through the specific example of natural deduction as our logic. Our presentation of natural deduction will be in the same style as in the lecture notes of Frank Pfenning~\cite{natded-pfenning}.

A \textit{formula} is an expression that represents a true or false statement. We can write a grammar for the formulas of a given logic. For example, for natural deduction formulas are from the following grammar:
$$
p, q ::= \mathit{True} \; | \; p \wedge q \; | \; p \vee q \; | \; p \supset q
$$

The symbols $\wedge$, $\vee$, and $\supset$ are called \textit{connectives}. Think of a connective as notation for an adjesive that connects formulas. The connectives in the grammar are all binary connectives because they all build a new formula from two smaller ones. The grammar tells us how to build formulas, but not what they mean. For example, if we have some formulas $P$ and $Q$, then we can build a new formula $P \wedge Q$, but we don't know what this expression means yet. The semantics of formulas come from a set of inference rules for the logic.

An \textit{inference rule} is a structure that tells us how to build a formula or take it apart. These rules give meaning to the connectives used in them. The notation for an inference rule is as shown in Figure~\ref{fig:infrule} and as described presently. It has the premises of the rule written beside each other, with some space between assumptions, above a horizontal line which is above the conclusion of the rule. The name of the rule is written to the right of the horizontal line and any side conditions that must hold are written to the left of the line. There may be some slight variation in laying out inference rules in other writings, but here we will follow the conventions described above.

The premises and conclusion of a rule are \textit{judgments}. Like a formula, a judgment is a statement that is true or false. When a judgment is derived by a rule, we consider it true, assuming the premises of the rule are derivable. In our natural deduction example, when we see a formula $p$ in a rule or proof, we will understand it to mean $p$ \textit{is true}. This diverges from the Martin-L{\"o}f approach followed by Pfenning in~\cite{natded-pfenning} where there is a more explicit distinction between the formula $p$ and the judgment $p \; \mathit{true}$. (TODO: justify our approach; more accessible to beginners, and the initiated user could eventually add their own proof with explicit judgments)

TODO: what proof trees are evidence of: sequent in natded example \\

NEXT: how do we build a proof, what are the parts, how to read a proof, what is proven (sequent when leaves are premises), extensions of what can be allowed in the nodes (leave this for discussion?) \\

The rules for natural deduction can be seen in Figure~\ref{fig:natdedrules}. The formulas seen in the rules are called \textit{meta-variables}. For example, in the rule $\wedge_I$, the formulas $P$ and $Q$ are meta-variables for the rule. To use rules in building a proof, we fill in meta-variables consistently and match the top-level symbols used when applying a sequence of rules. For example, the proof in Figure~\ref{fig:andcomm} shows that the connective $\wedge$ is commutative. (TODO: finish explanation of how rules used). If we can build a tree structure using the rules this way (TODO: expand) such that the leaves of the tree are the desired assumptions and the root is the desired goal, then we have built a \textit{proof tree}.

A \textit{sequent} is an object containing a set of formulas $P_1, \dots, P_k$ representing a set of premises and a formula $G$ representing a goal. It is notated $P_1, \dots, P_k \vdash G$ and means if you assume all of $P_1, \dots, P_k$, then you can derive $G$.

The root of a proof tree is the goal to be derived and the leaves are premises. We understand a proof tree with leaves $L_1, \dots, L_k$ and root $R$ to be a proof of the sequent $L_1, \dots, L_k \vdash R$.

\begin{figure}

\caption{Inference rules for natural deduction}
\label{fig:natdedrules}
\end{figure}

\begin{figure}

\caption{Proof that $\wedge$ is commutative}
\label{fig:andcomm}
\end{figure}

\begin{figure}

\begin{prooftree}
\AxiomC{Premise 1}
\AxiomC{$\dots$}
\AxiomC{Premise n}
\LeftLabel{\small conditions}
\RightLabel{\small rule name}
\TrinaryInfC{Conclusion}
\end{prooftree}

\caption{Structure of inference rules}
\label{fig:infrule}
\end{figure}


TODO: examples, not super formal (rules, proof) \\

TODO: more emphasis on goal-directed reading of proof, discussion of forward vs backward reasoning


\section{Tool Description and User Tasks}
\label{sec:tooldesc}

\begin{figure}

\begin{center}
\frame{\includegraphics[width=3.3in]{resources/screenshot_andcomm2.png}}
\end{center}

\caption{Screenshot of \projectname{} with green node containing $q$ focused}
\label{fig:screenshot}

\end{figure}

\projectname{} is implemented as a web page. A screenshot of the page can be seen in Figure~\ref{fig:screenshot}. The major elements at the top of the page include a panel for the title and any future menu and below this a controls panel for example selection and moving through a proof walk-through.

First the user selects an example from the drop-down list in the controls panel. We have chosen examples from~\cite{logicincs-huth+ryan}, an introductory logic textbook, to ensure a breadth of examples appropriate for beginner audiences. This updates the main display area of the page, the tree display panel, with a proof tree corresponding to the selected example.

The selected example proof tree represents a proof within a specific logic, so once an example is selected the rules panel to the right of the tree display panel is populated with the rules of that logic.

Once a tree is displayed, the user has the option of open exploration of the proof, called \textit{explore mode}, or a directed walk-through, called \textit{walk-through mode}. In explore mode, a node containing a judgment can be selected for focus. Once this is done, nodes in the tree are coloured to make the selection most salient, while also highlighting the children of the current node and making nodes occurring earlier in the proof traversal less visible. At the same time, information related to the focused node is displayed in the selection panel.

Recall that our reading of the proof has a goal-directed view, with reasoning in the backward direction from goal to assumptions (see Section~\ref{sec:background}). With this in mind, the focused node selection information includes the judgment contained in the selected node, the rule used to derive this judgment, and the instantiated premise(s) of that rule. For example, in Figure~\ref{fig:screenshot}, the selected judgment is the formula $q$, which is derived by applying the rule $\wedge_{E_2}$ to the premise $p \wedge q$. So the rule $\wedge_{E_2}$ is used with $P_1$ and $P_2$ instantiated as $p$ and $q$, respectively.

In walk-through mode, the information displayed for the focused node and colouring of nodes in the tree is the same as in explore mode, but the method for focusing nodes is different. In a walk-through, the arrows in the controls panel of the page are used to navigate forward and backward through the steps of the proof, again with a goal-directed reading.

TODO: discuss current vs future versions of the project? \\

TODO: link to project in paper? \\


\section{Technology}
\label{sec:technology}

This project is implemented as a web page, so the main languages used are the standard web development languages: HTML, CSS, and JavaScript. By implementing the tool as a web page, it is more easily accessible for a wide audience. The lack of type safety in JavaScript may make it a poor choice for a project where correctness is of vital importance, but it is a good choice for quickly prototyping a visualization project (boo bad? leave these opinions out? I think a logic/proof community may want to know why such a language is chosen).

Proof trees are laid out approximately following the Tilford-Reingold-Walker algorithm, described in more detail later (TODO internal ref to proper section?). Rather than implementing this algorithm directly, we use D3 trees. D3 trees accept a tree data object that contains at least fields for name and children (TODO: check that this is correct), and computes the positions of the nodes according to the Tilford-Reingold-Walker algorithm.

A proof tree is drawn quite differently from other trees, and this causes some challenges in implementation. Before discussing the differences, we will look at how proof trees are similar to standard tree objects. Proof trees have nodes, and there is a relationship that can be defined between the nodes. There is a unique root, and a unique path from the root to any leaf. We can see that a proof tree is in fact a tree, but in this specific application we attach some extra data to each node.

Every node has a field for a judgment. Recall this is some expression that is either true or false. Each logic will have different grammars or rules for how to construct these expressions. Non-leaf nodes all have a field for the rule that was used to derive the contained judgment. Leaf nodes that represent hypothetical assumptions (for example, in the rule $\supset_I$) use the rule name field for the assumption label. Leaf nodes representing premises of the proof have no field for rule name or label. Note that our abstraction of the tree object favours the backward reasoning discussed earlier, because at each node, this rule name field tells us "how did we get here?" rather than "how do we keep going?", and allows us to work from a node to its children.

Our drawing of the tree differs from the standard tree drawing in a few ways. We don't draw links or edges between connected nodes. Instead, we separate a node from its children with a horizontal line with the rule name to the right of the line and any side-conditions to the left, following the convention for drawing inference rules (see TODO: ref). Note that the rule name and side condition are data from the node below the inference line.

The standard audience for this work will typically have seen math content and proof trees laid out as when using \LaTeX{} languages. Here we try to respect the traditions from which this work is motivated. The math content seen in this tool is written in \LaTeX{} and laid out by MathJax (ref?).

A few challenges arise in our handling of the layout of math content. Since the mathematical expresions are initially written in \LaTeX{}, they are almost always much larger than the final typeset expression. For example, the expression \$(p \textbackslash wedge q) \textbackslash vee r\$ requires more width than its typeset version $(p \wedge q) \vee r$. This means that D3 allocates more space to these nodes than they need, which is fine, but this has implications for drawing other tree content.

To draw the inference line between a node and its children and draw the rule name and any side conditions, we need to know the location of the bottom left of the first child and the bottom right of the last child. So the content of the tree must be drawn in a very particular order. First, all nodes are positioned according to the content of their \textit{judgment} field, then once MathJax has finished this first typesetting, we can position the inference line and rule name. To position any side condition or text to the left of the inference line, we need to know the typeset width of the side condition text so we know how far to shift it to the left. To make this possible, we add the side condition to the page after (TODO: check) the initial node positioning so that it will be typeset by MathJax, but don't display it. Then once MathJax has run again, we can position the side condition properly.

TODO: sketch of computations for positioning content? something like a box model? \\

TODO: describe initial attempts to use CSS Grid layout? \\

TODO: use of d3 for visualization management and page manipulation \\

TODO: high-level description of program structure and techniques (e.g. function closures, traversal as callback to two-way iterator) \\


\section{InfoVis Elements}
\label{sec:infoviselem}

% interaction

TODO: review both proposal and presentation and make list of elements from class and their references

- TRW algorithm for layout

- Focus+context: shows relationship of focus node to children and parent

- interaction

  * overview/explore: full tree view and navigation

  * select: display information on focused node

- colour: highlight focused node and related nodes and categorizing nodes (e.g. children, visited); attention on spatially disconnected elements simultaneously

\section{Evaluation}
\label{sec:evaluation}

% from cognitive dimensions paper; low priority for this report, work on this once everything else is done

\section{Discussion}
\label{sec:discussion}

% how to use this for other logics
% implications of choice of logic (see fewer benefits for simpler logic, but easier to explain and learn)
% Limitation: natural deduction proofs are made more naturally using other visualization methods, e.g. Fitch style, where you don't know the shape of the proof yet
% forward vs backward reasoning

It is our hope that the tool will be useful as an educational resource and for documentation.

Future updates:

\begin{itemize}
    \item select rule from the collection of rules for the selected logic, and inferences using that rule will be highlighted
    \item minimize subtrees
    \item structure view
    \item writing to latex
    \item interface to build and modify trees
    \item when selecting a node, relevant rule is highlighted
    \item GUI builder, then user is also "writing" the proof
\end{itemize}

Terms for glossary or other special note:

\begin{itemize}
    \item proof
    \item logic
    \item formula
    \item judgment
    \item sequent
    \item inference rule
    \item proof tree
    \item assumption (leaf in tree)
    \item premise (can be intermediate in rules; top of an inference)
    \item hypothesis (hypothetical judgment)
    \item goal
\end{itemize}

TODO: hypothesis and assumption distinction somewhat arbitrary but needs to be clear here \\

TODO: udpate colours \\

TODO: future work note: using MathJax allows future extensions to the project in the form of a GUI builder where users can write LaTeX directly in a text box for a new node \\

There are critical limitations in the use of proof trees in certain mediums. Even a straightforward, ``small'' proof tree can easily escape the bounds of a sheet of paper. Creating a digital version eliminates bounds on the size of the tree, but it is still desirable to have all pertinent parts visible on a screen at the same time. A proof tree in the visualization created in this project will be an interactive, digital version where subtrees can be hidden. This will be done by selecting an icon on the node that will cause the subtree rooted at that node to be minimized. It will be ideal for the transitions when minimizing or expanding subtrees be as smooth as possible to avoid disrupting the mental model of the data.

Weber and Mejia-Ramos~\cite{majorsbeliefs-weber+mejiaramos} and Alcock and Wilkinson~\cite{eproofs-alcock+wilkinson} have argued that too much detail visible in a proof obscures high-level structural information which is important for proof comprehension. To address this concern, there will be two views for this proof visualization: detail view and structure view. Detail view will show a proof tree, possibly with subtrees hidden as discussed above, with full formulas, rule names, and rule side conditions. Structure view will show the shape of the tree and which rules are used.

\section{Conclusion}
\label{sec:conclusion}

% summarize the tool, its purpose, and topics presented in this paper... review of everything? expanded abstract like intro, but with less motivation, more tech detail?

% \makeglossaries

\section{Temporary TODO}

\begin{itemize}
\item more design sketches
\item expand to a tutorial, link to this from the page? (add as GitHub issue)
\item glossary of terms?
\item what is a logic? what is a proof in this context?
\item direct reader to other source to learn about natural deduction?
\item list of terms
\item natural deduction rules
\item clear use of premise (tree leaves) and assumption (hypothetical, in rules)
\end{itemize}

\bibliography{visualanalytics_reportbib}
\bibliographystyle{plain}

\end{document}