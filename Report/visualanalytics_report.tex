\documentclass[conference]{IEEEtran}
% \documentclass{article}

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{bussproofs,proof}

\usepackage{array}

\usepackage{xcolor,latexsym,mathtools}

\usepackage{enumitem}
\usepackage{graphicx}

% \usepackage{glossaries}


% \usepackage[page]{appendix}

\newcommand{\projectname}{Treehehe}

\begin{document}

\title{Treehehe: An interactive visualization of proof trees
}

\author{\IEEEauthorblockN{Chelsea Battell}
\IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
\textit{University of Ottawa}\\
Ottawa, Canada \\
cbattell@uottawa.ca}
}

% \author{\IEEEauthorblockN{1\textsuperscript{st} Chelsea Battell}
% \IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
% \textit{University of Ottawa}\\
% Ottawa, Canada \\
% cbattell@uottawa.ca}
% }

\maketitle

~\cite{infovis-ware}



% \begin{enumerate}
%     \item Introduction. \\
%         In one sentence, what’s the topic? Phrase it in a way that your reader will understand. If you’re writing a PhD thesis, your readers are the examiners – assume they are familiar with the general field of research, so you need to tell them specifically what topic your thesis addresses. Same advice works for scientific papers – the readers are the peer reviewers, and eventually others in your field interested in your research, so again they know the background work, but want to know specifically what topic your paper covers. \\

\newcommand{\sentenceone}{Proofs are commonly illustrated as trees to make the structure of the argument salient.}
%     \item State the problem you tackle. \\
%         What’s the key research question? Again, in one sentence. (Note: For a more general essay, I’d adjust this slightly to state the central question that you want to address) Remember, your first sentence introduced the overall topic, so now you can build on that, and focus on one key question within that topic. If you can’t summarize your thesis/paper/essay in one key question, then you don’t yet understand what you’re trying to write about. Keep working at this step until you have a single, concise (and understandable) question. \\

\newcommand{\sentencetwo}{A proof tree can be tedious to record and as a static object it does not realize its full potential as a route to comprehension of the proof it represents.}

%     \item Summarize (in one sentence) why nobody else has adequately answered the research question yet. \\
%         For a PhD thesis, you’ll have an entire chapter, covering what’s been done previously in the literature. Here you have to boil that down to one sentence. But remember, the trick is not to try and cover all the various ways in which people have tried and failed; the trick is to explain that there’s this one particular approach that nobody else tried yet (hint: it’s the thing that your research does). But here you’re phrasing it in such a way that it’s clear it’s a gap in the literature. So use a phrase such as “previous work has failed to address…”. (if you’re writing a more general essay, you still need to summarize the source material you’re drawing on, so you can pull the same trick – explain in a few words what the general message in the source material is, but expressed in terms of what’s missing) \\

\newcommand{\sentencethree}{There is literature on how to use visualization to support mathematics education and implementations of visual tools to walk through real analysis proofs~\cite{eproofs-alcock+wilkinson}, but none of this related work addresses the use of interactive proof trees or visualization for the proof theory community.}
%     \item Explain, in one sentence, how you tackled the research question. \\
%         What’s your big new idea? (Again for a more general essay, you might want to adapt this slightly: what’s the new perspective you have adopted? or: What’s your overall view on the question you introduced in step 2?) \\

\newcommand{\sentencefour}{To address this gap, we implement a tool for interacting with visual representations of proof trees to provide insight into the structure of the proof and its founding logic.}

%     \item In one sentence, how did you go about doing the research that follows from your big idea. \\
%         Did you run experiments? Build a piece of software? Carry out case studies? This is likely to be the longest sentence, especially if it’s a PhD thesis – after all you’re probably covering several years worth of research. But don’t overdo it – we’re still looking for a sentence that you could read aloud without having to stop for breath. Remember, the word ‘abstract’ means a summary of the main ideas with most of the detail left out. So feel free to omit detail! (For those of you who got this far and are still insisting on writing an essay rather than signing up for a PhD, this sentence is really an elaboration of sentence 4 – explore the consequences of your new perspective).

\newcommand{\sentencefive}{The proof visualization tool allows either open exploration of a proof or a directed walk-through, revealing supplementary information to serve as a form of discourse as the nodes are visited.}

%     \item As a single sentence, what’s the key impact of your research? \\
%         Here we’re not looking for the outcome of an experiment. We’re looking for a summary of the implications. What’s it all mean? Why should other people care? What can they do with your research. (Essay folks: all the same questions apply: what conclusions did you draw, and why would anyone care about them?)

\newcommand{\sentencesix}{This work provides a tool for gaining understanding of the structure of proofs, insight into the processes used in constructing such proofs, and also serves as a starting point for visualizations of proof trees in more complicated logics.}

% \end{enumerate}



\begin{abstract}
    \sentenceone{} \sentencetwo{} \sentencethree{} \sentencefour{} \sentencefive{} \sentencesix{}
\end{abstract}


\begin{IEEEkeywords}
    information visualization, visual analytics, proof visualization, proof tree, proof theory, mathematics education
\end{IEEEkeywords}


\section{Introduction}

% discuss application domain and problem area
% discussion of learning math and using visualizations... math education literature
% where to put user tasks?
% discussion of math education papers
% motivation

$p \wedge q \vdash q \wedge p$ \\

TODO: expand on abstract \\

TODO: intro on math and logic stuff... proof... etc \\

TODO: articulate goals of project better? \\

In this information visualization tool, data elements are trees. More specifically, they are visual representations of proof trees. A proof tree is an object that shows the structure of a logical argument.

The intended use of this tool is for exploring proofs of statements, leading to insight on the specific proof being explored, as well as the logic used to construct it.
- tool is for learning a logic and how to use it

- terms to cover in the intro: proof

- Application Domain/objective: gain insight on proofs and proof systems by exploring proof trees

- proof: argument obeying logic rules, connecting assumptions and a goal

- some brief discussion of literature on learning math with visualizations?

TODO: summary of paper structure \\

Before further discussion of the visualization tool, we will take a step back to review the logic concepts needed to understand how to use it. A brief tutorial will be presented (remove sentence?). Next, the tool and expected user tasks will be described. Following an initial discussion of the tool and how to use it, we discuss the technologies used to implement it. InfoVis results used to motivate the design of the tool will be explored in the next section. Finally, we discuss benefits and limitations of the tool, future work, and finish with a conclusion reviewing what is presented here. We hope the reader will be left with an understanding of the motivation for and use of this tool and know how InfoVis techniques implemented here help users to learn about specific proofs and their founding logics (todo... make better).

TODO: objective/goal/hopes for reader? \\



\section{Logic Background / Tutorial}

TODO: what is a logic? a proof in this context? \\

This tool is for visualizing structured data, but the data belongs to a very specialized area. Before we can discuss the tool in detail, it is necessary to first review the application area. Below we will review the basics of logic to understand the use of proof trees and present a brief tutorial.

A \textit{formula} is an expression we build that represents a true or false statement.

TODO: talk about connectives as adhesives, given some other formulas to build them

An \textit{inference rule} is a structure that tells us how to build a formula or take it apart. These rules give meanings to the connectives used in them.

TODO: talk about building vs taking apart, the structure/notation of rules, give examples

- judgment

To use rules, we fill in the meta-variables consistently.... sequence of using rules. If we can build a tree structure using the rules this way such that the leaves of the tree are the desired assumptions and the root is the desired goal, then we have built a \textit{proof tree}.

TODO: examples, not super formal \\

TODO: more emphasis on goal-directed reading of proof, discussion of forward vs backward reasoning

TODO:
\begin{itemize}
\item glossary of terms
\item review discussion of quick tutorial from presentation
\end{itemize}



\section{Tool Description and User Tasks}

\begin{figure}

\begin{center}
\frame{\includegraphics[width=3.3in]{resources/screenshot_andcomm2.png}}
\end{center}

\caption{Screenshot of \projectname{} with green node containing $q$ focused}
\label{fig:screenshot}

\end{figure}

\projectname{} is implemented as a web page. A screenshot of the page can be seen in Figure~\ref{fig:screenshot}. The major elements at the top of the page include a panel for the title and any future menu and below this a controls panel for example selection and moving through a proof walk-through.

First the user selects an example from the drop-down list in the controls panel. This updates the main display area of the page, the tree display panel, with a proof tree corresponding to the selected example.

The selected example proof tree represents a proof within a specific logic, so once an example is selected the rules panel to the right of the tree display panel is populated with the rules of that logic.

Once a tree is displayed, the user has the option of open exploration of the proof, called \textit{explore mode}, or a directed walk-through, called \textit{walk-through mode}. In explore mode, a node containing a judgment can be selected for focus. Once this is done, nodes in the tree are coloured to make the selection most salient, while also highlighting the children of the current node and making nodes occurring earlier in the proof traversal less visible. At the same time, information related to the focused node is displayed in the selection panel.

Recall that our reading of the proof has a goal-directed view, with reasoning in the backward direction from goal to assumptions (see TODO ref previous section). With this in mind, the focused node selection information includes the judgment contained in the selected node, the rule used to derive this judgment, and the instantiated premise(s) of that rule. For example, in Figure~\ref{fig:screenshot}, the selected judgment is the formula $q$, which is derived by applying the rule $\wedge_{E_2}$ to the premise $p \wedge q$. So the rule $\wedge_{E_2}$ is used with $P_1$ and $P_2$ instantiated as $p$ and $q$, respectively.

In walk-through mode, the information displayed for the focused node and colouring of nodes in the tree is the same as in explore mode, but the method for focusing nodes is different. In a walk-through, the arrows in the controls panel of the page are used to navigate forward and backward through the steps of the proof, again with a goal-directed reading.

TODO: discuss current vs future versions of the project? \\

TODO: link to project in paper? \\


\section{Technology}

This project is implemented as a web page, so the main languages used are the standard web development languages: HTML, CSS, and JavaScript. By implementing the tool as a web page, it is more easily accessible for a wide audience. The lack of type safety in JavaScript may make it a poor choice for a project where correctness is of vital importance, but it is a good choice for quickly prototyping a visualization project (boo bad? leave these opinions out? I think a logic/proof community may want to know why such a language is chosen).

Proof trees are laid out approximately following the Tilford-Reingold-Walker algorithm, described in more detail later (TODO internal ref to proper section?). Rather than implementing this algorithm directly, we use D3 trees. D3 trees accept a tree data object that contains at least fields for name and children (TODO: check that this is correct), and computes the positions of the nodes according to the Tilford-Reingold-Walker algorithm.

A proof tree is drawn quite differently from other trees, and this causes some challenges in implementation. Before discussing the differences, we will look at how proof trees are similar to standard tree objects. Proof trees have nodes, and there is a relationship that can be defined between the nodes. There is a unique root, and a unique path from the root to any leaf. We can see that a proof tree is in fact a tree, but in this specific application we attach some extra data to each node.

Every node has a field for a judgment. Recall this is some expression that is either true or false. Each logic will have different grammars or rules for how to construct these expressions. Non-leaf nodes all have a field for the rule that was used to derive the contained judgment. Leaf nodes that represent hypothetical assumptions (for example, in the rule $\supset_I$) use the rule name field for the assumption label. Leaf nodes representing premises of the proof have no field for rule name or label. Note that our abstraction of the tree object favours the backward reasoning discussed earlier, because at each node, this rule name field tells us "how did we get here?" rather than "how do we keep going?", and allows us to work from a node to its children.

Our drawing of the tree differs from the standard tree drawing in a few ways. We don't draw links or edges between connected nodes. Instead, we separate a node from its children with a horizontal line with the rule name to the right of the line and any side-conditions to the left, following the convention for drawing inference rules (see TODO: ref). Note that the rule name and side condition are data from the node below the inference line.

The standard audience for this work will typically have seen math content and proof trees laid out as when using \LaTeX{} languages. Here we try to respect the traditions from which this work is motivated. The math content seen in this tool is written in \LaTeX{} and laid out by MathJax (ref?).

A few challenges arise in our handling of the layout of math content. Since the mathematical expresions are initially written in \LaTeX{}, they are almost always much larger than the final typeset expression. For example, the expression \$(p \textbackslash wedge q) \textbackslash vee r\$ requires more width than its typeset version $(p \wedge q) \vee r$. This means that D3 allocates more space to these nodes than they need, which is fine, but this has implications for drawing other tree content.

To draw the inference line between a node and its children and draw the rule name and any side conditions, we need to know the location of the bottom left of the first child and the bottom right of the last child. So the content of the tree must be drawn in a very particular order. First, all nodes are positioned according to the content of their \textit{judgment} field, then once MathJax has finished this first typesetting, we can position the inference line and rule name. To position any side condition or text to the left of the inference line, we need to know the typeset width of the side condition text so we know how far to shift it to the left. To make this possible, we add the side condition to the page after (TODO: check) the initial node positioning so that it will be typeset by MathJax, but don't display it. Then once MathJax has run again, we can position the side condition properly.

TODO: sketch of computations for positioning content? something like a box model? \\

TODO: describe initial attempts to use CSS Grid layout? \\

TODO: use of d3 for visualization management and page manipulation \\

TODO: reorder so that tree abstraction stuff and drawing details are earlier? \\

TODO: high-level description of program structure and techniques (e.g. function closures, traversal as callback to two-way iterator) \\


\section{InfoVis Elements}

% interaction

TODO: review both proposal and presentation and make list of elements from class and their references

- TRW algorithm for layout

- Focus+context: shows relationship of focus node to children and parent

- interaction

  * overview/explore: full tree view and navigation

  * select: display information on focused node

- colour: highlight focused node and related nodes and categorizing nodes (e.g. children, visited); attention on spatially disconnected elements simultaneously

\section{Evaluation}

% from cognitive dimensions paper; low priority for this report, work on this once everything else is done

\section{Discussion}

% how to use this for other logics
% implications of choice of logic (see fewer benefits for simpler logic, but easier to explain and learn)
% Limitation: natural deduction proofs are made more naturally using other visualization methods, e.g. Fitch style, where you don't know the shape of the proof yet
% forward vs backward reasoning

Future updates:

\begin{itemize}
    \item select rule from the collection of rules for the selected logic, and inferences using that rule will be highlighted
    \item minimize subtrees
    \item structure view
    \item writing to latex
    \item interface to build and modify trees
    \item when selecting a node, relevant rule is highlighted
\end{itemize}

TODO: udpate colours \\

TODO: future work note: using MathJax allows future extensions to the project in the form of a GUI builder where users can write LaTeX directly in a text box for a new node \\

\section{Conclusion}

% summarize the tool, its purpose, and topics presented in this paper... review of everything? expanded abstract like intro, but with less motivation, more tech detail?

% \makeglossaries

\bibliography{visualanalytics_reportbib}
\bibliographystyle{plain}

\end{document}