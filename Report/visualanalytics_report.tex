\documentclass[conference]{IEEEtran}
% \documentclass{article}

\usepackage{cite,hyperref}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{bussproofs,proof}

\usepackage{array,tabu}

\usepackage{xcolor,latexsym,mathtools}

\usepackage{enumitem}
\usepackage{graphicx}

% \usepackage{glossaries}


% \usepackage[page]{appendix}

\newcommand{\projectname}{Treehehe}

\begin{document}

\title{\projectname{}: An interactive visualization of proof trees
}

\author{\IEEEauthorblockN{Chelsea Battell}
\IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
\textit{University of Ottawa}\\
Ottawa, Canada \\
cbattell@uottawa.ca}
}

% \author{\IEEEauthorblockN{1\textsuperscript{st} Chelsea Battell}
% \IEEEauthorblockA{\textit{School of Electrical Engineering and Computer Science} \\
% \textit{University of Ottawa}\\
% Ottawa, Canada \\
% cbattell@uottawa.ca}
% }

\maketitle


% \begin{enumerate}
%     \item Introduction. \\
%         In one sentence, what’s the topic? Phrase it in a way that your reader will understand. If you’re writing a PhD thesis, your readers are the examiners – assume they are familiar with the general field of research, so you need to tell them specifically what topic your thesis addresses. Same advice works for scientific papers – the readers are the peer reviewers, and eventually others in your field interested in your research, so again they know the background work, but want to know specifically what topic your paper covers. \\

\newcommand{\sentenceone}{Proofs are commonly illustrated as trees to make the structure of the argument salient.}
%     \item State the problem you tackle. \\
%         What’s the key research question? Again, in one sentence. (Note: For a more general essay, I’d adjust this slightly to state the central question that you want to address) Remember, your first sentence introduced the overall topic, so now you can build on that, and focus on one key question within that topic. If you can’t summarize your thesis/paper/essay in one key question, then you don’t yet understand what you’re trying to write about. Keep working at this step until you have a single, concise (and understandable) question. \\

\newcommand{\sentencetwo}{A proof tree can be tedious to record and as a static object it does not realize its full potential as a route to comprehension of the proof it represents.}

%     \item Summarize (in one sentence) why nobody else has adequately answered the research question yet. \\
%         For a PhD thesis, you’ll have an entire chapter, covering what’s been done previously in the literature. Here you have to boil that down to one sentence. But remember, the trick is not to try and cover all the various ways in which people have tried and failed; the trick is to explain that there’s this one particular approach that nobody else tried yet (hint: it’s the thing that your research does). But here you’re phrasing it in such a way that it’s clear it’s a gap in the literature. So use a phrase such as “previous work has failed to address…”. (if you’re writing a more general essay, you still need to summarize the source material you’re drawing on, so you can pull the same trick – explain in a few words what the general message in the source material is, but expressed in terms of what’s missing) \\

\newcommand{\sentencethree}{There is literature on how to use visualization to support mathematics education and implementations of visual tools to walk through real analysis proofs~\cite{eproofs-alcock+wilkinson}, but none of this related work addresses the use of interactive proof trees or visualization for the proof theory community.}
%     \item Explain, in one sentence, how you tackled the research question. \\
%         What’s your big new idea? (Again for a more general essay, you might want to adapt this slightly: what’s the new perspective you have adopted? or: What’s your overall view on the question you introduced in step 2?) \\

\newcommand{\sentencefour}{To address this gap, we implement a tool for interacting with visual representations of proof trees to provide insight into the structure of the proof and its founding logic.}

%     \item In one sentence, how did you go about doing the research that follows from your big idea. \\
%         Did you run experiments? Build a piece of software? Carry out case studies? This is likely to be the longest sentence, especially if it’s a PhD thesis – after all you’re probably covering several years worth of research. But don’t overdo it – we’re still looking for a sentence that you could read aloud without having to stop for breath. Remember, the word ‘abstract’ means a summary of the main ideas with most of the detail left out. So feel free to omit detail! (For those of you who got this far and are still insisting on writing an essay rather than signing up for a PhD, this sentence is really an elaboration of sentence 4 – explore the consequences of your new perspective).

\newcommand{\sentencefive}{The proof visualization tool allows either open exploration of a proof or a directed walk-through, revealing supplementary information to serve as a form of discourse as the nodes are visited.}

%     \item As a single sentence, what’s the key impact of your research? \\
%         Here we’re not looking for the outcome of an experiment. We’re looking for a summary of the implications. What’s it all mean? Why should other people care? What can they do with your research. (Essay folks: all the same questions apply: what conclusions did you draw, and why would anyone care about them?)

\newcommand{\sentencesix}{This work provides a tool for gaining understanding of the structure of proofs, insight into the processes used in constructing such proofs, and also serves as a starting point for visualizations of proof trees in more complicated logics.}

% \end{enumerate}



\begin{abstract}
    \sentenceone{} \sentencetwo{} \sentencethree{} \sentencefour{} \sentencefive{} \sentencesix{}
\end{abstract}


\begin{IEEEkeywords}
    information visualization, visual analytics, proof visualization, proof tree, proof theory, mathematics education
\end{IEEEkeywords}


\section{Introduction}
\label{sec:intro}

Proofs are naturally visual artifacts and an essential part of comprehension and advancement in logic. They are a requirement for confidence in the logician's intellectual explorations and constructions. A proof is a logical argument providing evidence of the truth of some statement. It connects assumptions and a goal through the application of rules that preserve truth. These arguments have a tree structure with the goal as the root and the assumptions as leaves. We call a drawing of a proof as a tree a \textit{proof tree}. This work presents a tool to allow a user to explore proof trees and to gain insight in to specific proofs and the logics they are built from.

Proof trees are a common visual representation used to illustrate both the structure and details of a logical argument. There are many advantages to be found using proof trees: they are useful for learning about a logic through experimentation with writing proofs, they reveal structure in the proof that a linear proof presentation may obscure, they allow cognitive offloading when working through a challenging argument, and they can serve as a form of documentation.

There are critical limitations in the use of proof trees in certain mediums. Even a straightforward, ``small'' proof tree can easily escape the bounds of a sheet of paper. Creating a digital version eliminates bounds on the size of the tree.

In~\cite{eproofs-alcock+wilkinson}, Alcock and Wilkinson present a tool for walking through analysis proofs. The proofs are written as they typically would be in analysis lecture notes, with a combination of text explanations and mathematical notation. Users are able to step through a proof and graphical elements are used to bring the reader's attention to the current point in the proof, as well as link to dependencies elsewhere in the proof. We hope to provide the logic and proof theory community with a resource with benefits similar to what e-proofs provide in analysis lectures. We also see \projectname{} as having utility in addition to increased comprehension, such as sparking further insight on logical systems and being a resource for experimentation and documentation. We also hope to add more features to further this goal. This is discussed in Section~\ref{sec:future}.

A proof tree is a static object which requires some level of expertise to be parsed by the reader. \projectname{} adds interaction to proof trees to help the user understand and explore them. In~\cite{repvisvis-duval}, Duval criticizes proof trees and mathematics visualizations by arguing that they don’t aid in operational or discursive comprehension. In this case he is speaking of static graphics and figures used when learning mathematics. To overcome this limitation of static proof trees, the user is able to interact with the proof in two distinct ways.

The first is in the form of a proof walk-through that supports operational comprehension by guiding the user through the steps of the proof. At every stage in the walk-through, there is a node that is focused. The second form of interaction allows more free-form exploration of the proof tree. The user can click on any node to focus on it. Colour is used to bring attention to the currently focused node and to distinguish between previously seen inferences and future inferences. Past nodes are coloured to be less visible. Another panel on the page has information on how the focused node is derived to provide discourse.

Before further discussion of the visualization tool, we will take a step back to review the logic concepts needed to understand how to use it. Next, the tool and expected user tasks will be described. Following an initial discussion of the tool and how to use it, we discuss the technologies used to implement it. InfoVis results motivating the design of the tool will be explored in the next section. Finally, we discuss benefits and limitations of the tool, future work, and finish with a conclusion reviewing what is presented here. We hope the reader will be left with an understanding of the motivation for and use of \projectname{} and know how InfoVis techniques implemented here help users to learn about specific proofs and proof systems.

\section{Logic Background}
\label{sec:background}

Recall that the deliverable of \projectname{}, the tool described in this report, is an interactive visualization of proof trees. Before we can discuss the tool in detail, it is necessary to first review the application area. We will present the basics of logic, inference systems and proof trees from these systems. We will aim to discuss these preliminary concepts generally, while carrying through the specific example of natural deduction, first proposed by Gentzen~\cite{natded-gentzen}, as our logic. Our presentation of the natural deduction system is motivated by~\cite[1.2 Natural Deduction]{logicincs-huth+ryan} and the lecture notes of Frank Pfenning~\cite{natded-pfenning}.

A \textit{formula} is an expression that represents a true or false statement. We can write a grammar for the formulas of a given logic. For example, in natural deduction formulas are described by the following grammar:
$$
F ::= \top \; | \; \bot \; | \; F \wedge F \; | \; F \vee F \; | \; F \supset F
$$
Note that below we allow parentheses to be used to denote precedence.

The symbols $\wedge$, $\vee$, and $\supset$ are called \textit{connectives}. Think of a connective as notation for an adhesive that connects formulas. The connectives in the grammar for natural deduction formulas are all binary connectives because they all build a new formula from two smaller ones. The symbols $\top$, $\bot$, and the connectives are the \textit{logical constants} of this language of expressions.

The grammar tells us how to build formulas, but not what they mean. For example, given formulas $p$, $q$, and $r$, we can build the expression $((p \wedge q) \vee r) \supset ((p \vee r) \wedge (q \vee r))$ from the grammar above, but without any understanding of the semantics of the logical constants this is simply a string of symbols without meaning. We don't know if the expression is true or false. The semantics of formulas can be encoded in a set of inference rules for the logic.

An \textit{inference rule} is a structure that tells us how to derive a formula. The notation for an inference rule is as shown in Figure~\ref{fig:infrule}. It has the premises of the rule written beside each other, with consistent space in between, above a horizontal line which is above the conclusion of the rule. The name of the rule is written to the right of the horizontal line and any side conditions that must hold are written to the left of the line. There may be some slight variation in laying out inference rules in other writings, but here we will follow the conventions described above. The meaning of this inference rule is ``if we either assume or derive $\mathit{Premise}_1$ to $\mathit{Premise}_n$, then we can derive $\mathit{Conclusion}$''.

\begin{figure}[h]

\begin{prooftree}
\AxiomC{$\mathit{Premise_1}$}
\AxiomC{$\dots$}
\AxiomC{$\mathit{Premise_n}$}
\LeftLabel{\small conditions}
\RightLabel{\small rule name}
\TrinaryInfC{$\mathit{Conclusion}$}
\end{prooftree}

\caption{Structure of inference rules}
\label{fig:infrule}
\end{figure}

Inference rules tell us how to build a formula or take it apart. These rules give meaning to the logical constants used in them. For example, see Figure~\ref{fig:natdedrules} for the rules of natural deduction. Rules with names containing ``I'' are called introduction rules because a logical constant is introduced in the conclusion of the rule. Rules with names containing ``E'' are called elimination rules because a logical constant that occurrs in one of the premises is eliminated and is not present in the conclusion.

We will explain the rules $\wedge_I$ and $\wedge_{E_i}$ since they are used in an example proof later in this paper, but we do not describe the full set in Figure~\ref{fig:natdedrules} here. For a more complete explanation of the rules, we direct the reader to the lecture notes by Pfenning~\cite{natded-pfenning}, the textbook Logic in Computer Science~\cite{logicincs-huth+ryan} by Huth and Ryan, or to the Wikipedia entry on natural deduction. By considering the collection of natural deduction rules one can deduce that the symbols $\top$, $\bot$, $\wedge$, $\vee$, and $\supset$ mean ``true'', ``false'', ``and'', ``or'', and ``implies'', respectively.

We understand the rule $\wedge_I$ to mean if we can assume or derive $P_1$ and $P_2$, then we can use this rule to derive the formula $P_1 \wedge P_2$, introducing a formula with the symbol $\wedge$. The rule $\wedge_{E_i}$ tells us that if we can assume or derive the formula $P_1 \wedge P_2$, then we can derive each of $P_1$ and $P_2$ on their own by applying this rule, eliminating a formula with the symbol $\wedge$. This is consistent of our natural understanding of the word ``and'', which the logical constant $\wedge$ represents. Later we will see how to use these rules to prove that $\wedge$ is commutative; that is, expressions $p \wedge q$ and $q \wedge p$ have the same truth-value.

\begin{figure}

\begin{center}
\begin{tabu} to 0.5\textwidth { X[c,b] X[c,b] }

$$
\infer[\wedge_I]{P_1 \wedge P_2}{P_1 & P_2}
$$

&

$$
\infer[\wedge_{E_i}]{P_i}{P_1 \wedge P_2}
$$

\\

$$
\infer[\vee_{I_i}]{P_1 \vee P_2}{P_1}
$$

&

$$
\infer[\vee_{E^{u,w}}]{P_3}{P_1 \vee P_2 &
    \infer*{P_3}{\infer[u]{P_1}{}} &
    \infer*{P_3}{\infer[w]{P_2}{}}}
$$

\\

$$
\infer[\supset_{I^u}]{P_1 \supset P_2}{\infer*{P_2}{\infer[u]{P_1}{}}}
$$

&

$$
\infer[\supset_E]{P_2}{P_1 \supset P_2 & P_1}
$$

\\[-20pt]

$$
\infer[\top_I]{\top}{}
$$

&

$$
\infer[\bot_E]{P}{\bot}
$$

\end{tabu}
\end{center}

\caption{Inference rules for natural deduction}
\label{fig:natdedrules}
\end{figure}


Suppose we wish to prove that from the $n$ assumptions $A_1, \dots , A_n$, we can derive the conclusion $C$. This goal can be written as $A_1, \dots, A_n \vdash C$, called a \textit{sequent}. So a sequent is an object containing a set of formulas representing a set of assumptions and a formula representing a conclusion, notated as just shown.

In our application, the root of a proof tree is the conclusion to be derived and the leaves are assumptions. We understand a proof tree with leaves $A_1, \dots, A_k$ and root $C$ built with correct application of rules and consistent substitutions for rule variables to be a proof of the sequent $A_1, \dots, A_k \vdash C$. For example, in Figure~\ref{fig:andcomm}, we see a tree with the unique leaf formula $p \wedge q$ and the conclusion $q \wedge p$. If the inferences are all valid, then this is a proof of $p \wedge q \vdash q \wedge p$.

\begin{figure}[h]

\begin{prooftree}
\AxiomC{$p \wedge q$}
\RightLabel{$\wedge_{E_2}$}
\UnaryInfC{$q$}

\AxiomC{$p \wedge q$}
\RightLabel{$\wedge_{E_1}$}
\UnaryInfC{$p$}

\RightLabel{$\wedge_I$}
\BinaryInfC{$q \wedge p$}
\end{prooftree}

\caption{Proof that $\wedge$ is commutative}
\label{fig:andcomm}
\end{figure}

We wish to check that the proof of $p \wedge q \vdash q \wedge p$ in Figure~\ref{fig:andcomm} is valid. To check this proof, we will begin at the root. The formula at the root of the proof tree, our conclusion, is $q \wedge p$. The only rule that could have been used to derive this formula is $\wedge_I$ applied to premises $q$ and $p$ (in that order). The first premise can be derived by the rule $\wedge_{E_2}$ applied to the premise $p \wedge q$. We stop this line of reasoning here and allow $p \wedge q$ to remain an assumption. Back to the first inference considered, we had a second premise $p$. The formula $p$ can be derived by the rule $\wedge_{E_1}$ applied to $p \wedge q$. We are already seeing $p \wedge q$ as an assumption, so we can halt our proof search/check here. We now see that the proof tree in Figure~\ref{fig:andcomm} is a valid proof tree providing evidence of $p \wedge q \vdash q \wedge p$.

Notice that in working through the example proof above, we began with the conclusion of the proof, rather than working from assumptions to conclusion. We favour the former backward reasoning style, but one could also read the proof in the forward direction, beginning with assumptions. This choice will be discussed further in Section~\ref{sec:discussion}.

\section{Tool Description and User Tasks}
\label{sec:tooldesc}

\begin{figure}

\begin{center}
\frame{\includegraphics[width=3.3in]{resources/screenshot_andcomm2.png}}
\end{center}

\caption{Screenshot of \projectname{} with green node containing $q$ focused}
\label{fig:screenshot}

\end{figure}

\projectname{} is implemented as a webpage. A screenshot of the page can be seen in Figure~\ref{fig:screenshot}. The major elements at the top of the page include a panel for the title and any future menu and below this a controls panel for example selection and stepping through a proof.

First the user selects an example from the drop-down list in the controls panel. We have chosen examples from~\cite{logicincs-huth+ryan}, an introductory logic textbook, to ensure a breadth of examples accessible to beginner audiences, although more complicated examples from varied logics could easily be added to the system. This is explained in Section~\ref{sec:discussion}. Example selection updates the main display area of the page, the tree display panel, with a proof tree corresponding to the selected example.

The selected example proof tree represents a proof within a specific logic, so once an example is selected the rules panel to the right of the tree display panel is populated with the rules of that logic. These rules can be reviewed on their own or referenced as they are used while working on understanding a proof.

Once a tree is displayed, the user has the option of open exploration of the proof, called \textit{explore mode}, or a directed walk-through, called \textit{walk-through mode}. In explore mode, any node containing a formula can be selected for focus. Once this is done, nodes in the tree are coloured to make the selection most salient, while also highlighting the children of the current node and making nodes occurring earlier in the proof traversal less visible. At the same time, information related to the focused node is displayed in the selection panel.

Recall that our reading of the example proof in the previous section applied reasoning in the backward direction from goal to assumptions. With this in mind, the focused node selection information includes the formula contained in the selected node, the rule used to derive this formula, and the instantiated premise(s) of that rule. For example, in Figure~\ref{fig:screenshot}, the selected formula is the formula $q$, which is derived by applying the rule $\wedge_{E_2}$ to the premise $p \wedge q$. So the rule $\wedge_{E_2}$ is used with $P_1$ and $P_2$ instantiated as $p$ and $q$, respectively.

In walk-through mode, the information displayed for the focused node and colouring of nodes in the tree is the same as in explore mode, but the method for focusing nodes is different. In a walk-through, the arrows in the controls panel of the page are used to navigate forward and backward through the steps of the proof, again with a backward reasoning reading. The nodes are visited following a preorder depth-first traversal. This is a reading of the proof that seems intuitive to the author, but could easily be changed to other traversals if they seem a better fit. We consider this further in Section~\ref{sec:discussion}.


\section{Technology}
\label{sec:technology}

This project is implemented as a webpage, so the main languages used are the standard web development languages: HTML, CSS, and JavaScript. Trees are implemented as JSON objects. Although the design does not prioritize small-screen devices, Flexbox has been used to help make the page responsive. By implementing the tool as a webpage, it is more easily accessible for a wide audience. The lack of type safety in JavaScript may make it a poor choice for a project where correctness is of vital importance, but it is a good choice for relatively quick development of a visualization project. The page is hosted using GitHub pages. As of this writing, it can be found at \url{http://chelsea.lol/treehehe}. This tool has been tested on Google Chrome v70.0.3538.110.

Proof trees are laid out following an efficient generalization of the Tilford-Reingold algorithm, described in more detail in Section~\ref{sec:infoviselem}. Rather than implementing this algorithm directly, we use D3 trees. A D3 tree accepts an object that contains at least fields for name and children, recursively nested with each child containing the same fields, and computes the positions of the nodes according to the tree layout algorithm.

A proof tree is drawn quite differently from standard tree drawings, and this causes some challenges in implementation. Rather than being represented as a point, a node in a proof tree contains a formula so nodes have varied widths. Also, we don't draw links or edges between connected nodes. Instead, we separate a node from its children with a horizontal line with the rule name to the right of the line and any side-conditions to the left, following the convention for drawing inference rules presented in Section~\ref{sec:background}. Note that the rule name and side condition are data connected to the node below the inference line.

Before discussing the differences in the tree data, we will look at how proof trees are similar to standard tree objects. Proof trees have nodes, and there is a relationship that can be defined between the nodes. The relations representing the invisible tree edges are ``is derived from'' and ``is used to derive''. There is a unique root, and a unique path from the root to any leaf. We can see that a proof tree is in fact a tree, but in this specific application we attach some extra data to each node.

Every node has a field for a formula. Recall this is some expression that is either true or false. Each logic will have different expression grammars and rules for how to construct these expressions. Non-leaf nodes all have a field for the name of the rule that was used to derive the contained formula. Leaf nodes that represent hypothetical assumptions (for example, $P_1$ in the premise of the rule $\supset_I$ in Figure~\ref{fig:natdedrules}) use the rule name field for the hypothesis label. Leaf nodes representing unlabelled assumptions of the proof have no value in the field for rule name. Note that our abstraction of the tree object favours the backward reasoning discussed in the proof check in Section~\ref{sec:background}, because at each node, this rule name field tells us "how did we get here?" rather than "how do we keep going?", and directs the user from a node to its children.

The standard audience for this work will typically have seen math content and proof trees laid out as when using \LaTeX{} languages. Here we try to respect the traditions from which this work is motivated. The math content seen in this tool is written in \LaTeX{} and embedded in HTML using MathJax. Since we want the tree to be interactive, we don't write the full tree in \LaTeX{}, but only the node content.

A few challenges arise in our handling of the layout of math content. Since the mathematical expresions are initially written in \LaTeX{}, they are almost always much larger than the final typeset expression. For example, the expression \$(p \textbackslash wedge q) \textbackslash vee r\$ requires more width than its typeset version $(p \wedge q) \vee r$. This means that D3 allocates more space to these nodes than they need, which is fine, but this has implications for drawing other tree content.

To draw the inference line between a node and its children and draw the rule name and any side conditions, we need to know the location of the bottom left of the first child and the bottom right of the last child after typesetting. So the content of the tree must be drawn in a very particular order. First, all nodes are positioned according to the content of their ``formula'' field, then once MathJax has finished this first typesetting, we can position the inference line and rule name. To position any side condition or text to the left of the inference line, we need to know the typeset width of the side condition text so we know how far to shift it to the left. To make this possible, we add the side condition to the page after the initial node positioning so that it will be typeset by MathJax, but we don't display it yet. Then once MathJax has run again, we can position the side condition properly.


\section{InfoVis Elements}
\label{sec:infoviselem}

Data in this visualization project are trees, so an important first consideration is determining a visual formalism for drawing trees that is consistent with conventions for this task. Herman et al.~\cite{graphvis-herman+melancon+marshall} discuss a number of techniques for visualizing trees. Several spacesaving representations are presented, such as H-tree layout, radial view, and balloon view. In \projectname{}, much of the utility of a proof tree comes from being able to read a flow of inferences, seeing the leaves as axioms or assumptions and the root as the conclusion of the proof. Each node contains a propositional formula, so to be readable all nodes need to have the same orientation.

The space-saving layouts could be useful if it is clear which node is the root and some other form of iconography could be used for constructing formulas. For the current project, we will use the Reingold and Tilford layout for trees, which could be described as visually rooted, since we have a convention that tells us which node we see as the root. We want to allow for inferences with more than two premises, so we need the version of the Reingold and Tilford algorithm extended by Walker to general trees~\cite{generaltreeslayout-walker}.

TODO: linear time improvement by Buchheim et al \\

We will invert the standard tree constructed with this algorithm so that the root is at centre bottom. The bottom center location of the root is a consistent position where we can find the goal of the proof, which is also the formula on the right side of a sequent, as described in section~\ref{sec:background}. Another benefit of the Reingold and Tilford algorithm for this application is the vertical alignment of nodes at the same level (distance from the root) in a proof. This allows a final difference between proof trees and general trees without making the relations between nodes unclear: we don't draw and links or edges between nodes. Instead, a horizontal line is drawn between a node and its children.

TODO: can expand on TRW algorithm if there is more space by talking about aesthetic requirements \\

TODO: more description of structure of proof trees used by math and logic community? \\

TODO: focus+context here: children <- focus -> parent \\

In~\cite[Chapter 3]{infovis-ware} we learn many best practices from Ware for using colour in a visualization. In \projectname{}, colour is used to highlight a selected node in a proof tree to bring the focus of the user to the current inference of interest. We also use colour to categorize nodes. Colour is preattentively processed, so as described in~\cite[Chapter 11]{infovis-ware} the user is able to have attention on spatially disconnected elements without each element being the current fixation. We use this property of attention to allow the user to attend to and distinguish between groups of nodes, such as previously visited nodes, future nodes, and the current focus.

Figueiras presents a taxonomy of interaction consisting of eleven categories of techniques~\cite{interaction-figueiras}. The categories of interaction used in this project are \textit{select} and \textit{overview/explore}.

A user may want to select data to learn more about it or track how it changes in response to other interaction. In \projectname{}, a node can be selected to see more detail on its role in the proof tree. Its related parent and child inferences can be highlighted, the rules used displayed, and the substitutions used in applying the rules explicitly stated.

Techniques in the overview/explore category first display an overview of the data, then allow exploration through zooming, filtering, and the display of details on demand. Large proof trees may sometimes escape the bounds of a monitor, so it may not be possible to have a full proof tree visible. Thus a proper ``overview'' is not guaranteed in all cases, but the full tree is available in the application, possibly requiring panning. (TODO: remove? does this not work anymore? review other interaction stuff? is using the walkthrough considered exploring?)

Lin and Yang~\cite{readingcompgeometric-lin+yang} (TODO: check that used correct reference here) present five facets of proof comprehension: basic knowledge, logical status, summary, generality, and application. These facets are used to guide the design of this project. (TODO: read this... add more... lower priority than visual thinking content)

Yi et al. observe that sensemaking is one path to insight~\cite{insights-yi+etal}. Sensemaking, in the context of interactive visualizations, is an intentional process in which a person continually reframes their understanding of a concept. The authors also propose four processes for gaining insight: provide overview, adjust, detect pattern, and match mental model.

Provide overview means a user can gain a higher-level understanding of a data set. In \projectname{}, this is realized in the viewing of a complete proof tree.

(Through adjust, a user is able to explore a data set. This can come from a variety of interaction techniques, such as adjustments to the level of abstraction, or selecting a range of values. In \projectname{}, the alternation between detail and structure view and the hiding of subtrees can help the user develop insight about the logic and formula proven.) (TODO: remove adjust?)

When new structure is observed in data and possibly new discoveries made, the user has been able to detect a pattern. In \projectname{}, examples of how this is realized include observing repeated arguments in a proof and being able to detect loops.

Match mental model means one has a bridge between the data and their mental model of it. Having an external visual version of the mental model allows for cognitive offloading. In this project, we will see the value of having a visualization of a proof to interact with rather than trying to hold the entire picture in one’s head. It is then possible to allocate more mental resources to reasoning and gaining insight through the other processes.

TODO: review second half of course content for other relevant readings \\

TODO: visual thinking content \\

\section{Evaluation}
\label{sec:evaluation}

% from cognitive dimensions paper; low priority for this report, work on this once everything else is done
% review handouts from the class where this was discussed


\section{Discussion}
\label{sec:discussion}

There are many decisions made in implementing and describing this project that the reader may wish to see motivated or explained further. We attempt to address these here. These extra discussions may be of interest to the curious reader but can be freely skipped.

In this paper we have used natural deduction as the example system when presenting the logic background and describing how to use the tool. In the current version of \projectname{}, most examples are natural deduction proofs. This logic was chosen because it is usually the first inference system presented in an introductory logic course, so it made sense as the system to use to make this paper readable to as wide an audience as reasonable. It also helped keep the presentation of background information manageable. A critical observation to make here is that there is nothing in the system that requires a user to commit to a single logic.

Since the tree data is a JSON object, the tree content can contain any string and thus be from any logic. An implication of this is that there is no check for correctness of the proof being displayed. In its current version, \projectname{} is only for visualization and not verification.

In the version of \projectname{} released with this paper, there is one example that is not a natural deduction proof. This is to illustrate the points just made. This example is a proof of $\Sigma ; P \vdash \exists M, \mathit{length} \; (1 :: 2 :: 3 :: [ \, ]) \; M$, a formalization of a Prolog query. Without being too pedantic, this query asks if there is an $M$ such that $M$ is the length of the list $(1 :: 2 :: 3 :: [\, ])$. The expression query above is the root node of the proof tree. In this example in the webpage we can see how this query is proven in Prolog and how the value of $M$ is computed to be 3.

A reader more familiar with, and favouring, the Martin-L{\"o}f approach to natural deduction may be wondering why we have not made an explicit distinction between formulas and judgments as in~\cite{natded-pfenning}. What we mean here is if we want to derive that formula $p$ is true, the node in the proof tree should say this explicitly, i.e., the node would contain the judgment $p \; \mathit{true}$. The current presentation has preferred the more condensed presentation where whenever we see a formula $p$ in a proof, we assume that this means $p$ is true. Aside from a smaller use of space, another benefit is we avoid the discussion of judgments vs formulas, making the presentation easier to digest for less experienced users and readers. As mentioned above, the experienced user could build a proof tree in this system where the judgment is clearly distinguished from the formula.

In \projectname{}, we have used a depth-first preorder traversal. A traversal had to be chosen to implement the proof walk-through and this choice of traversal felt intuitive to the author. If a user wishes to use a different traversal or it is found that another traversal would improve congnition in learning about proofs and logic, the change could be made fairly simply in the system. A two-way iterator was implemented to step forward or backward through the proof. This iterator accepts a callback representing a function to traverse a tree. This could either be updated only in the code, or a control could be added to the page so the user could select from a few traversal options.

Related to the traversal discussion, when we walked through an example in Section~\ref{sec:background}, we began with the root node. This backward reasoning is useful in automated reasoning, because we know we are starting with the root node and there is typically a finite set of rules that could have been used to infer that node (often only one rule). Starting with assumptions or leaves of the tree might feel more natural, because we start with what we know and work towards a goal. The issue with forward reasoning when constructing a tree is we don't know ahead of time what shape the tree will take and there is nothing in the shape of axioms or assumptions to guide our construction. So in building a proof without already knowing it, there is often a more algorithmic approach to the tree construction with backward reasoning than with forward. With all this said, in some logics (including natural deduction) backward reasoning alone is often not sufficiently intuitive, and in this case allowing the user to select different traversals would be useful.

\section{Future Work}
\label{sec:future}

There are many additions that could be made to this work to implement more lessons from the information visualization community and also to make the tool more useful for a range of proof-related tasks. We will first look at the updates in the InfoVis area.

Since large proof trees can escape the bounds of a digital display, navigation is another topic explored by Herman et al.~\cite{graphvis-herman+melancon+marshall} that is relevant to this project. The user will want to be able to scroll around the graph while exploring. The technique of incremental exploration and navigation can be used to display only a desired subtree of the proof; nodes will have an icon to either exclusively display or to hide the subtree that it is the root of. (TODO: check if covered in InfoVis elements)

Weber and Mejia-Ramos~\cite{majorsbeliefs-weber+mejiaramos} and Alcock and Wilkinson~\cite{eproofs-alcock+wilkinson} have argued that too much detail visible in a proof obscures high-level structural information which is important for proof comprehension. To address this concern, a future version will have two views for the proof display: detail view and structure view. Detail view will show a proof tree, possibly with subtrees hidden as discussed above, and with full formulas, rule names, and rule side conditions as presented in the rest of this paper. Structure view will show only the shape of the tree and which rules are used. (TODO: graphic showing this)

The interaction technique abstract/elaborate presented by Yi et al.~\cite{interaction-yietal} and Figueiras~\cite{interaction-figueiras} is used to adjust the level of abstraction of the data. By including a separate structure view option as previously described, this tool will have an abstract view displaying the structure and an elaborate view displaying full proof detail.

The final InfoVis updates we propose involve the rules panel on the page. When selecting a node, there is supplementary information displayed below the tree, including the name of the rule used to derive the focused node. We would like to highlight the rule used to derive the focused node so that it is easier for the user to move their fixation to the rule being used and connect the children of the focused node with the premises of the rule. In the other direction, we would also like the user to be able to select a rule from the rules panel and have uses of this rule in the proof tree be highlighted.% (TODO: visual?).

Other updates would add more uses for the tool that are extraneous to information visualization. Once a proof is built, the user may want to present it in a \LaTeX{} document. It would be a small change to export the \LaTeX{} code for the tree from the JSON object representing the tree. Another helpful update is to add ``help'' information in the form of easily readable instructions on how to use the tool and a tutorial on natural deduction. A final modification would allow the user to also ``write'' the proofs using the tool.

In the current version of \projectname{}, there are a number of examples the user can choose to explore, but the tool would be far more useful if there was a way to add custom proofs. The best way for this to be done is to extend the interface so that new nodes can be added. Initial plans for this idea would add an icon to each node to add siblings, and another icon to each leaf node to make that node a result of an inference (i.e. add an inference line above), then children could be added above that node. The content of a new node would be entered in a text box and written in \LaTeX{}.% In this circumstance (better word?), the user is writing the proof, adding to ... (TODO: ref Duval work? Alcock?)

Once the project is updated to the point where a user can enter their own proof, it should also be a more pleasant experience than trying to write proof trees on paper. When writing a tree by hand on paper, you are more committed to the spatial position of the nodes you write; in \projectname{}, you will be able to easily modify the elements of the tree.

\section{Conclusion}
\label{sec:conclusion}

% \makeglossaries

In this paper we have seen how information visualization techniques can be used to make a tool for visualizing proof trees. Students studying logic in university will see proof trees during their studies. \projectname{} should help them gain confidence in using proof trees to construct logical arguments. Advanced users who write proofs in other formalisms, such as the Calculus of Constructions, or write logic program queries, may want to be able to be able to build a visual version of their proofs.

We presented the logical foundations necessary to understand how to use the \projectname{}. Following this, we saw how to use the tool, looking at each major area of the webpage, and reviewed the technologies used implementing the tool. Since this is an information visualization project, the InfoVis elements that helped guide the design are described. Finally, we attempted to address other concerns and questions that the reader might have and future modifications to the project.

It is our hope that this tool will be a useful resource for learning about formal reasoning. For more experienced users, we hope it will aid in the understanding of larger proofs in the proof-writing process and for documenting reasoning.


% TODO: motivation: logic is scary and intimidating for beginners? put this in conclusion?

% TODO: proof as argument \textit{obeying} logic rules \\


% (Interaction is an essential component of this project because it elevates a proof tree from a static graphic to a visualization that can lead to further understanding and insight along a variety of paths. Duval claims that proof trees are disappointing and visualizations in general do not lead to immediate comprehension in mathematics~\cite{repvisvis-duval}. It appears that what is meant by visualization in this article only includes static graphics representing mathematical objects. He also does not fully explore other advantages to explicit articulation of proof trees, such as cognitive offloading and observation of patterns in large proofs, which are particularly useful in proofs where the goal to be proven has a complicated logical structure. Here we propose that adding interaction to a proof tree will aid in understanding of both the logic used to build it and the proposition being proven, although this is stated without evidence and without a study to verify this hypothesis. There is more to discuss relating Duval’s work to what is being attempted here, and this will be expanded on in the final report.) (TODO: repetitive; bring some of these points to the conclusion? discussion?)

% Dump:
%
% (A formula in an inference rule represented by a symbol that is not one of the logical constants of the expression language is called a \textit{meta-variable}. For example, in the rule $\wedge_I$, the formulas $P_1$ and $P_2$ are meta-variables for the rule. To use rules in building a proof, we fill in meta-variables consistently and match the top-level symbols used when applying a sequence of rules. For example, the proof in Figure~\ref{fig:andcomm} shows that the connective $\wedge$ is commutative. (TODO: finish explanation of how rules used). If we can build a tree structure using the rules this way (TODO: expand) such that the leaves of the tree are the desired assumptions and the root is the desired goal, then we have built a \textit{proof tree}.) (TODO: move or remove?)



\section{Temporary TODO}

Terms for glossary or other special note:

\begin{itemize}
    \item proof
    \item logic
    \item formula
    \item judgment
    \item sequent
    \item inference rule
    \item proof tree
    \item assumption (leaf in tree, left side of sequent)
    \item premise (can be intermediate in rules; top of an inference)
    \item hypothesis (hypothetical judgment)
    \item goal vs conclusion
    \item logical constant
\end{itemize}

\bibliography{visualanalytics_reportbib}
\bibliographystyle{plain}

\end{document}