\documentclass[journal]{vgtc}                % final (journal style)
%\documentclass[review,journal]{vgtc}         % review (journal style)
%\documentclass[widereview]{vgtc}             % wide-spaced review
%\documentclass[preprint,journal]{vgtc}       % preprint (journal style)

%% Uncomment one of the lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and the final version
%% doesn't use a specific qualifier.

%% Please use one of the ``review'' options in combination with the
%% assigned online id (see below) ONLY if your paper uses a double blind
%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT
%% in the past.

%% Please note that the use of figures other than the optional teaser is not permitted on the first page
%% of the journal version.  Figures should begin on the second page and be
%% in CMYK or Grey scale format, otherwise, colour shifting may occur
%% during the printing process.  Papers submitted with figures other than the optional teaser on the
%% first page will be refused. Also, the teaser figure should only have the
%% width of the abstract as the template enforces it.

%% These few lines make a distinction between latex and pdflatex calls and they
%% bring in essential packages for graphics and font handling.
%% Note that due to the \DeclareGraphicsExtensions{} call it is no longer necessary
%% to provide the the path and extension of a graphics file:
%% \includegraphics{diamondrule} is completely sufficient.
%%
\ifpdf%                                % if we use pdflatex
  \pdfoutput=1\relax                   % create PDFs from pdfLaTeX
  \pdfcompresslevel=9                  % PDF Compression
  \pdfoptionpdfminorversion=7          % create PDF 1.7
  \ExecuteOptions{pdftex}
  \usepackage{graphicx}                % allow us to embed graphics files
  \DeclareGraphicsExtensions{.pdf,.png,.jpg,.jpeg} % for pdflatex we expect .pdf, .png, or .jpg files
\else%                                 % else we use pure latex
  \ExecuteOptions{dvips}
  \usepackage{graphicx}                % allow us to embed graphics files
  \DeclareGraphicsExtensions{.eps}     % for pure latex we expect eps files
\fi%

%% it is recomended to use ``\autoref{sec:bla}'' instead of ``Fig.~\ref{sec:bla}''
\graphicspath{{figures/}{pictures/}{images/}{./}} % where to search for the images

\usepackage{microtype}                 % use micro-typography (slightly more compact, better to read)
\PassOptionsToPackage{warn}{textcomp}  % to address font issues with \textrightarrow
\usepackage{textcomp}                  % use better special symbols
\usepackage{mathptmx}                  % use matching math font
\usepackage{times}                     % we use Times as the main font
\renewcommand*\ttdefault{txtt}         % a nicer typewriter font
\usepackage{cite}                      % needed to automatically sort the references
\usepackage{tabu}                      % only used for the table example
\usepackage{booktabs}                  % only used for the table example
%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

% non-template packages and commands
\usepackage{cite,hyperref}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{bussproofs,proof}

\usepackage{array,tabu}

\usepackage{xcolor,latexsym,mathtools}

\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{float,caption}

\newcommand{\projectname}{Treehehe}


%% In preprint mode you may define your own headline.
%\preprinttext{To appear in IEEE Transactions on Visualization and Computer Graphics.}

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}
%% please declare the paper type of your paper to help reviewers, only shown in review mode
%% choices:
%% * algorithm/technique
%% * application/design study
%% * evaluation
%% * system
%% * theory/model
\vgtcpapertype{system}

%% Paper title.
\title{\projectname{}: An interactive visualization of proof trees}

%% This is how authors are specified in the journal style

%% indicate IEEE Member or Student Member in form indicated below
\author{Chelsea Battell}
\authorfooter{
%% insert punctuation at end of each item
\item
 Chelsea Battell is with the School of Electrical Engineering and Computer Science at the University of Ottawa. E-mail: cbattell@uottawa.ca.
}

%other entries to be set up for journal
\shortauthortitle{Battell: Treehehe}
%\shortauthortitle{Firstauthor \MakeLowercase{\textit{et al.}}: Paper Title}


%% Abstract section.

% \begin{enumerate}
%     \item Introduction. \\
%         In one sentence, what’s the topic? Phrase it in a way that your reader will understand. If you’re writing a PhD thesis, your readers are the examiners – assume they are familiar with the general field of research, so you need to tell them specifically what topic your thesis addresses. Same advice works for scientific papers – the readers are the peer reviewers, and eventually others in your field interested in your research, so again they know the background work, but want to know specifically what topic your paper covers. \\

\newcommand{\sentenceone}{Proofs are commonly illustrated as trees to make the structure of the argument salient.}
%     \item State the problem you tackle. \\
%         What’s the key research question? Again, in one sentence. (Note: For a more general essay, I’d adjust this slightly to state the central question that you want to address) Remember, your first sentence introduced the overall topic, so now you can build on that, and focus on one key question within that topic. If you can’t summarize your thesis/paper/essay in one key question, then you don’t yet understand what you’re trying to write about. Keep working at this step until you have a single, concise (and understandable) question. \\

\newcommand{\sentencetwo}{A proof tree can be tedious to record and as a static object it does not realize its full potential as a route to comprehension of the proof it represents.}

%     \item Summarize (in one sentence) why nobody else has adequately answered the research question yet. \\
%         For a PhD thesis, you’ll have an entire chapter, covering what’s been done previously in the literature. Here you have to boil that down to one sentence. But remember, the trick is not to try and cover all the various ways in which people have tried and failed; the trick is to explain that there’s this one particular approach that nobody else tried yet (hint: it’s the thing that your research does). But here you’re phrasing it in such a way that it’s clear it’s a gap in the literature. So use a phrase such as “previous work has failed to address…”. (if you’re writing a more general essay, you still need to summarize the source material you’re drawing on, so you can pull the same trick – explain in a few words what the general message in the source material is, but expressed in terms of what’s missing) \\

\newcommand{\sentencethree}{There is literature on how to use visualization to support mathematics education and implementations of visual tools to walk through real analysis proofs, but none of this related work addresses the use of interactive proof trees or visualization for the proof theory community.}
%     \item Explain, in one sentence, how you tackled the research question. \\
%         What’s your big new idea? (Again for a more general essay, you might want to adapt this slightly: what’s the new perspective you have adopted? or: What’s your overall view on the question you introduced in step 2?) \\

\newcommand{\sentencefour}{To address this gap, we implement a tool for interacting with visual representations of proof trees to provide insight into the structure of the proof and its founding logic.}

%     \item In one sentence, how did you go about doing the research that follows from your big idea. \\
%         Did you run experiments? Build a piece of software? Carry out case studies? This is likely to be the longest sentence, especially if it’s a PhD thesis – after all you’re probably covering several years worth of research. But don’t overdo it – we’re still looking for a sentence that you could read aloud without having to stop for breath. Remember, the word ‘abstract’ means a summary of the main ideas with most of the detail left out. So feel free to omit detail! (For those of you who got this far and are still insisting on writing an essay rather than signing up for a PhD, this sentence is really an elaboration of sentence 4 – explore the consequences of your new perspective).

\newcommand{\sentencefive}{The proof visualization tool allows either open exploration of a proof or a directed walk-through, revealing supplementary information to serve as a form of discourse as the nodes are visited.}

%     \item As a single sentence, what’s the key impact of your research? \\
%         Here we’re not looking for the outcome of an experiment. We’re looking for a summary of the implications. What’s it all mean? Why should other people care? What can they do with your research. (Essay folks: all the same questions apply: what conclusions did you draw, and why would anyone care about them?)

\newcommand{\sentencesix}{This work provides a tool for gaining understanding of the structure of proofs, insight into the processes used in constructing such proofs, and also serves as a starting point for visualizations of proof trees in more complicated logics.}


\abstract{\sentenceone{} \sentencetwo{} \sentencethree{} \sentencefour{} \sentencefive{} \sentencesix{}%
} % end of abstract

%% Keywords that describe your work. Will show as 'Index Terms' in journal
%% please capitalize first letter and insert punctuation after last keyword
\keywords{information visualization, visual analytics, proof visualization, proof tree, proof theory, mathematics education}

%% ACM Computing Classification System (CCS).
%% See <http://www.acm.org/class/1998/> for details.
%% The ``\CCScat'' command takes four arguments.
% TODO
% \CCScatlist{ % not used in journal version
%  \CCScat{K.6.1}{Management of Computing and Information Systems}%
% {Project and People Management}{Life Cycle};
%  \CCScat{K.7.m}{The Computing Profession}{Miscellaneous}{Ethics}
% }

%% Uncomment below to include a teaser figure.
\teaser{
  \centering
  \includegraphics[width=0.36\linewidth]{resources/logo_v1.png}
  % \captionsetup{justification=centering}
  \caption{Experience the magic of interactive proof trees}
	\label{fig:teaser}
}

%% Uncomment below to disable the manuscript note
%\renewcommand{\manuscriptnotetxt}{}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

\vgtcinsertpkg

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

%% the only exception to this rule is the \firstsection command
\firstsection{Introduction}
\label{sec:intro}

\maketitle

%% \section{Introduction} %for journal use above \firstsection{..} instead

Proofs are naturally visual artifacts and an essential part of comprehension and advancement in logic. They are a requirement for confidence in the logician's intellectual explorations and constructions. A proof is a logical argument providing evidence of the truth of some statement. It connects assumptions and a goal through the application of rules that preserve truth. These arguments have a tree structure with the goal as the root and the assumptions as leaves. We call a drawing of a proof as a tree a \textit{proof tree}. This work presents a tool to allow a user to explore proof trees and to gain insight in to specific proofs and the logics they are built from.

Proof trees are a common visual representation used to illustrate both the structure and details of a logical argument. There are many advantages to be found using proof trees: they are useful for learning about a logic through experimentation with writing proofs, they reveal structure in the proof that a linear proof presentation may obscure, they allow cognitive offloading when working through a challenging argument, and they can serve as a form of documentation.

There are critical limitations in the use of proof trees in certain mediums. Even a straightforward, ``small'' proof tree can easily escape the bounds of a sheet of paper. Creating a digital version eliminates bounds on the size of the tree.

\begin{figure}[h]
\centering
\includegraphics[width=3.4in]{resources/andassoc.png}
\caption{A proof tree showing that the symbol $\wedge$ is associative in the logic used}
\end{figure}

A proof tree is a static object which requires some level of expertise to be parsed by the reader. \projectname{} adds interaction to proof trees to help the user understand and explore them. In~\cite{repvisvis-duval}, Duval criticizes proof trees and mathematics visualizations by arguing that they don’t aid in operational or discursive comprehension. In this case he is speaking of static graphics and figures used when learning mathematics. To overcome this limitation of static proof trees, the user is able to interact with the proof in two distinct ways.

The first is in the form of a proof walk-through that supports operational comprehension by guiding the user through the steps of the proof. At every stage in the walk-through, there is a node that is focused. The second form of interaction allows more free-form exploration of the proof tree. The user can click on any node to focus on it. Colour is used to bring attention to the currently focused node and to distinguish between previously seen inferences and future inferences. Past nodes are coloured to be less visible. Another panel on the page has information on how the focused node is derived to provide discourse.

In~\cite{eproofs-alcock+wilkinson}, Alcock and Wilkinson present a tool for walking through analysis proofs. The proofs are written as they typically would be in analysis lecture notes, with a combination of text explanations and mathematical notation. Users are able to step through a proof and graphical elements are used to bring the reader's attention to the current point in the proof, as well as link to dependencies elsewhere in the proof. Tools like this do not appear to exist for visualizing proof trees. We hope to provide the logic and proof theory community with a resource with benefits similar to what e-proofs provide in analysis lectures. We also see \projectname{} as having utility in addition to increased comprehension, such as sparking further insight on logical systems and being a resource for experimentation and documentation. We also hope to add more features to further this goal. This is discussed in Section~\ref{sec:future}.

Before further discussion of the visualization tool, we will take a step back to review the logic concepts needed to understand how to use it in Section~\ref{sec:background}. Next in Section~\ref{sec:design} we look at the original design, followed by the current design in Section~\ref{sec:tooldesc}, focusing on the tool description and expected user tasks. Following an initial discussion of the tool and how to use it, we discuss the technologies used to implement it in Section~\ref{sec:technology}. InfoVis results motivating the design of the tool will be explored in Section~\ref{sec:infoviselem}. Finally, in the remaining sections we discuss limitations and deeper topics related to the tool, future work, and finish with a conclusion reviewing what is presented here. We hope the reader will be left with an understanding of the motivation for and use of \projectname{} and know how InfoVis techniques implemented here help users to learn about specific proofs and proof systems.

\section{Logic Background}
\label{sec:background}

Recall that the deliverable of \projectname{}, the tool described in this report, is an interactive visualization of proof trees. Before we can discuss the tool in detail, it is necessary to first review the application area. We will present the basics of logic, inference systems and proof trees from these systems. We will aim to discuss these preliminary concepts generally, while carrying through the specific example of natural deduction, first proposed by Gentzen~\cite{natded-gentzen}, as our logic. Our presentation of the natural deduction system is motivated by~\cite[1.2 Natural Deduction]{logicincs-huth+ryan} and the lecture notes of Frank Pfenning~\cite{natded-pfenning}.

A \textit{formula} is an expression that represents a true or false statement. We can write a grammar for the formulas of a given logic. For example, in natural deduction formulas are described by the following grammar:
$$
F ::= \top \; | \; \bot \; | \; F \wedge F \; | \; F \vee F \; | \; F \supset F
$$
Note that below we allow parentheses to be used to denote precedence.

The symbols $\wedge$, $\vee$, and $\supset$ are called \textit{connectives}. Think of a connective as notation for an adhesive that connects formulas. The connectives in the grammar for natural deduction formulas are all binary connectives because they all build a new formula from two smaller ones. The symbols $\top$, $\bot$, and the connectives are the \textit{logical constants} of this language of expressions.

The grammar tells us how to build formulas, but not what they mean. For example, given formulas $p$, $q$, and $r$, we can build the expression $((p \wedge q) \vee r) \supset ((p \vee r) \wedge (q \vee r))$ from the grammar above, but without any understanding of the semantics of the logical constants this is simply a string of symbols without meaning. We don't know if the expression is true or false. The semantics of formulas can be encoded in a set of inference rules for the logic.

\begin{figure}[H]

\begin{prooftree}
\AxiomC{$\mathit{Premise_1}$}
\AxiomC{$\dots$}
\AxiomC{$\mathit{Premise_n}$}
\LeftLabel{\small conditions}
\RightLabel{\small rule name}
\TrinaryInfC{$\mathit{Conclusion}$}
\end{prooftree}

\caption{Structure of inference rules}
\label{fig:infrule}
\end{figure}

An \textit{inference rule} is a structure that tells us how to derive a formula. The notation for an inference rule is as shown in Figure~\ref{fig:infrule}. It has the premises of the rule written beside each other, with consistent space in between, above a horizontal line which is above the conclusion of the rule. The name of the rule is written to the right of the horizontal line and any side conditions that must hold are written to the left of the line. There may be some slight variation in laying out inference rules in other writings, but here we will follow the conventions described above. The meaning of this inference rule is ``if we either assume or derive $\mathit{Premise}_1$ to $\mathit{Premise}_n$, then we can derive $\mathit{Conclusion}$''.

Inference rules tell us how to build a formula or take it apart. These rules give meaning to the logical constants used in them. For example, see Figure~\ref{fig:natdedrules} for the rules of natural deduction. Rules with names containing ``I'' are called introduction rules because a logical constant is introduced in the conclusion of the rule. Rules with names containing ``E'' are called elimination rules because a logical constant that occurs in one of the premises is eliminated and is not present in the conclusion.

We will explain the rules $\wedge_I$ and $\wedge_{E_i}$ since they are used in an example proof later in this paper, but we do not describe the full set in Figure~\ref{fig:natdedrules} here. For a more complete explanation of the rules, we direct the reader to the lecture notes by Pfenning~\cite{natded-pfenning}, the textbook Logic in Computer Science~\cite{logicincs-huth+ryan} by Huth and Ryan, or to the Wikipedia entry on natural deduction. By considering the collection of natural deduction rules one can deduce that the symbols $\top$, $\bot$, $\wedge$, $\vee$, and $\supset$ mean ``true'', ``false'', ``and'', ``or'', and ``implies'', respectively.

We understand the rule $\wedge_I$ to mean if we can assume or derive $P_1$ and $P_2$, then we can use this rule to derive the formula $P_1 \wedge P_2$, introducing a formula with the symbol $\wedge$. The rule $\wedge_{E_i}$ tells us that if we can assume or derive the formula $P_1 \wedge P_2$, then we can derive each of $P_1$ and $P_2$ on their own by applying this rule, eliminating a formula with the symbol $\wedge$. This is consistent of our natural understanding of the word ``and'', which the logical constant $\wedge$ represents. Later we will see how to use these rules to prove that $\wedge$ is commutative; that is, expressions $p \wedge q$ and $q \wedge p$ have the same truth-value.

\begin{figure}

\begin{center}
\begin{tabu} to 0.5\textwidth { X[c,b] X[c,b] }

$$
\infer[\wedge_I]{P_1 \wedge P_2}{P_1 & P_2}
$$

&

$$
\infer[\wedge_{E_i}]{P_i}{P_1 \wedge P_2}
$$

\\

$$
\infer[\vee_{I_i}]{P_1 \vee P_2}{P_1}
$$

&

$$
\infer[\vee_{E^{u,w}}]{P_3}{P_1 \vee P_2 &
    \infer*{P_3}{\infer[u]{P_1}{}} &
    \infer*{P_3}{\infer[w]{P_2}{}}}
$$

\\

$$
\infer[\supset_{I^u}]{P_1 \supset P_2}{\infer*{P_2}{\infer[u]{P_1}{}}}
$$

&

$$
\infer[\supset_E]{P_2}{P_1 \supset P_2 & P_1}
$$

\\[-20pt]

$$
\infer[\top_I]{\top}{}
$$

&

$$
\infer[\bot_E]{P}{\bot}
$$

\end{tabu}
\end{center}

\caption{Inference rules for natural deduction}
\label{fig:natdedrules}
\end{figure}


Suppose we wish to prove that from the $n$ assumptions $A_1, \dots , A_n$, we can derive the conclusion $C$. This goal can be written as $A_1, \dots, A_n \vdash C$, called a \textit{sequent}. So a sequent is an object containing a set of formulas representing a set of assumptions and a formula representing a conclusion, notated as just shown.

In our application, the root of a proof tree is the conclusion to be derived and the leaves are assumptions. We understand a proof tree with leaves $A_1, \dots, A_k$ and root $C$ built with correct application of rules and consistent substitutions for rule variables to be a proof of the sequent $A_1, \dots, A_k \vdash C$. For example, in Figure~\ref{fig:andcomm}, we see a tree with the unique leaf formula $p \wedge q$ and the conclusion $q \wedge p$. If the inferences are all valid, then this is a proof of $p \wedge q \vdash q \wedge p$.

\begin{figure}[h]

\begin{prooftree}
\AxiomC{$p \wedge q$}
\RightLabel{$\wedge_{E_2}$}
\UnaryInfC{$q$}

\AxiomC{$p \wedge q$}
\RightLabel{$\wedge_{E_1}$}
\UnaryInfC{$p$}

\RightLabel{$\wedge_I$}
\BinaryInfC{$q \wedge p$}
\end{prooftree}

\caption{Proof that $\wedge$ is commutative}
\label{fig:andcomm}
\end{figure}

We wish to check that the proof of $p \wedge q \vdash q \wedge p$ in Figure~\ref{fig:andcomm} is valid. To check this proof, we will begin at the root. The formula at the root of the proof tree, our conclusion, is $q \wedge p$. The only rule that could have been used to derive this formula is $\wedge_I$ applied to premises $q$ and $p$ (in that order). The first premise can be derived by the rule $\wedge_{E_2}$ applied to the premise $p \wedge q$. We stop this line of reasoning here and allow $p \wedge q$ to remain an assumption. Back to the first inference considered, we had a second premise $p$. The formula $p$ can be derived by the rule $\wedge_{E_1}$ applied to $p \wedge q$. We are already seeing $p \wedge q$ as an assumption, so we can halt our proof search/check here. We now see that the proof tree in Figure~\ref{fig:andcomm} is a valid proof tree providing evidence of $p \wedge q \vdash q \wedge p$.

Notice that in working through the example proof above, we began with the conclusion of the proof, rather than working from assumptions to conclusion. We favour the former backward reasoning style, but one could also read the proof in the forward direction, beginning with assumptions. This choice will be discussed further in Section~\ref{sec:discussion}.


\section{Design}
\label{sec:design}

The main content to display in this tool is a proof tree, so we will first discuss the display of proof trees. For this task we follow the conventions for drawing proof trees in the math and logic community. Namely, uses of inference rules similar to those in Figure~\ref{fig:natdedrules} are chained together to build a tree with the proof conclusion at the root and assumptions at the leaves. More detail on the construction of proof trees can be found in Section~\ref{sec:background}.

We wish to be able to direct attention of the user to particular nodes in the tree. This is done using colour to highlight a node for focus and lightly bring attention to the children of the node, since they will follow in a proof traversal. Compare the \projectname{} version of the proof that $\wedge$ is commutative in Figure~\ref{fig:andcommtreehehe} with the standard proof tree showing the same fact in Figure~\ref{fig:andcomm}.

\begin{figure}[h]

\includegraphics[width=3.3in]{resources/andassoc_focus.png}

\caption{\projectname{} version of proof of associativity of $\wedge$ with node $p \wedge q$ focused}
\label{fig:andcommtreehehe}
\end{figure}

Important goals for the design of the project were to make it comfortable for users to explore a proof without necessarily being told what to do. To provide some form of discourse, supplementary information explaining how a selected node was derived and connecting it to the inference system was important.

\begin{figure}

\includegraphics[width=3.3in]{resources/page_layout_og.png}

\caption{Original \projectname{} design}
\label{fig:layoutog}

\end{figure}

It was clear that the following regions needed to be available on the page: title, example selection, tree display, selection information, and rules. See Figure~\ref{fig:layoutog} for a sketch of the initial page design. We also wanted to have controls to toggle between explore and walk-through modes and possibly alternative views for the tree, but we did not end up implementing alternative tree views. The distinction between walk-through and explore modes is now more in alternative ways of using the system, and we do not force this to be done by changing the mode of the entire application. Thus neither toggle control is included in the final version.

Controls that had not been considered in the initial version include navigation arrows for the walk-through and a drop-down list for the example selection. By containing the list of examples in a drop-down menu, the examples display no longer required a large amount of vertical space. It also became clear that the information on the selected node is usually a few long lines with some large spans of math content. From these insights the page display was redesigned. The content that was displayed did not change, but the location of much of it did. The current version of the design is described in detail in the next section.


\section{Tool Description and User Tasks}
\label{sec:tooldesc}

\begin{figure}

\begin{center}
\frame{\includegraphics[width=3.3in]{resources/screenshot_andcomm2.png}}
\end{center}

\caption{Screenshot of \projectname{} with green node containing $q$ focused}
\label{fig:screenshot}

\end{figure}

\projectname{} is implemented as a webpage. A screenshot of the page can be seen in Figure~\ref{fig:screenshot}. The major elements at the top of the page include a panel for the title and any future menu and below this a controls panel for example selection and stepping through a proof.

First the user selects an example from the drop-down list in the controls panel. We have chosen examples from~\cite{logicincs-huth+ryan}, an introductory logic textbook, to ensure a breadth of examples accessible to beginner audiences, although more complicated examples from varied logics could easily be added to the system. This is explained in Section~\ref{sec:discussion}. Example selection updates the main display area of the page, the tree display panel, with a proof tree corresponding to the selected example.

The selected example proof tree represents a proof within a specific logic, so once an example is selected the rules panel to the right of the tree display panel is populated with the rules of that logic. These rules can be reviewed on their own or referenced as they are used while working on understanding a proof.

Once a tree is displayed, the user has the option of open exploration of the proof, called \textit{explore mode}, or a directed walk-through, called \textit{walk-through mode}. In explore mode, any node containing a formula can be selected for focus. Once this is done, nodes in the tree are coloured to make the selection most salient, while also highlighting the children of the current node and making nodes occurring earlier in the proof traversal less visible. At the same time, information related to the focused node is displayed in the selection panel.

Recall that our reading of the example proof in the previous section applied reasoning in the backward direction from goal to assumptions. With this in mind, the focused node selection information includes the formula contained in the selected node, the rule used to derive this formula, and the instantiated premise(s) of that rule. For example, in Figure~\ref{fig:screenshot}, the selected formula is the formula $q$, which is derived by applying the rule $\wedge_{E_2}$ to the premise $p \wedge q$. So the rule $\wedge_{E_2}$ is used with $P_1$ and $P_2$ instantiated as $p$ and $q$, respectively.

In walk-through mode, the information displayed for the focused node and colouring of nodes in the tree is the same as in explore mode, but the method for focusing nodes is different. In a walk-through, the arrows in the controls panel of the page are used to navigate forward and backward through the steps of the proof, again with a backward reasoning reading. The nodes are visited following a preorder depth-first traversal. This is a reading of the proof that seems intuitive to the author, but could easily be changed to other traversals if they seem a better fit. We consider this further in Section~\ref{sec:discussion}.


\section{Implementation}
\label{sec:technology}

This project is implemented as a webpage, so the main languages used are the standard web development languages: HTML, CSS, and JavaScript. Trees are implemented as JSON objects. Although the design does not prioritize small-screen devices, Flexbox has been used to help make the page responsive. By implementing the tool as a webpage, it is more easily accessible for a wide audience. The lack of type safety in JavaScript may make it a poor choice for a project where correctness is of vital importance, but it is a good choice for relatively quick development of a visualization project. The page is hosted using GitHub pages. As of this writing, it can be found at \href{chelsea.lol/treehehe}{http://chelsea.lol/treehehe}. This tool has been tested on Google Chrome v70.0.3538.110.

Proof trees are laid out following an efficient generalization of the Tilford-Reingold algorithm, described in more detail in Section~\ref{sec:infoviselem}. Rather than implementing this algorithm directly, we use D3 trees. A D3 tree accepts an object that contains at least fields for name and children, recursively nested with each child containing the same fields, and computes the positions of the nodes according to the tree layout algorithm.

A proof tree is drawn quite differently from standard tree drawings, and this causes some challenges in implementation. Rather than being represented as a point, a node in a proof tree contains a formula so nodes have varied widths. Also, we don't draw links or edges between connected nodes. Instead, we separate a node from its children with a horizontal line with the rule name to the right of the line and any side-conditions to the left, following the convention for drawing inference rules presented in Section~\ref{sec:background}. Note that the rule name and side condition are data connected to the node below the inference line.

Before discussing the differences in the tree data, we will look at how proof trees are similar to standard tree objects. Proof trees have nodes, and there is a relationship that can be defined between the nodes. The relations representing the invisible tree edges are ``is derived from'' and ``is used to derive''. There is a unique root, and a unique path from the root to any leaf. We can see that a proof tree is in fact a tree, but in this specific application we attach some extra data to each node.

Every node has a field for a formula. Recall this is some expression that is either true or false. Each logic will have different expression grammars and rules for how to construct these expressions. Non-leaf nodes all have a field for the name of the rule that was used to derive the contained formula. Leaf nodes that represent hypothetical assumptions (for example, $P_1$ in the premise of the rule $\supset_I$ in Figure~\ref{fig:natdedrules}) use the rule name field for the hypothesis label. Leaf nodes representing unlabeled assumptions of the proof have no value in the field for rule name. Note that our abstraction of the tree object favours the backward reasoning discussed in the proof check in Section~\ref{sec:background}, because at each node, this rule name field tells us "how did we get here?" rather than "how do we keep going?", and directs the user from a node to its children.

The standard audience for this work will typically have seen math content and proof trees laid out as when using \LaTeX{} languages. Here we try to respect the traditions from which this work is motivated. The math content seen in this tool is written in \LaTeX{} and embedded in HTML using MathJax. Since we want the tree to be interactive, we don't write the full tree in \LaTeX{}, but only the node content.

A few challenges arise in our handling of the layout of math content. Since the mathematical expressions are initially written in \LaTeX{}, they are almost always much larger than the final typeset expression. For example, the expression \$(p \textbackslash wedge q) \textbackslash vee r\$ requires more width than its typeset version $(p \wedge q) \vee r$. This means that D3 allocates more space to these nodes than they need, which is fine, but this has implications for drawing other tree content.

To draw the inference line between a node and its children and draw the rule name and any side conditions, we need to know the location of the bottom left of the first child and the bottom right of the last child after typesetting. So the content of the tree must be drawn in a very particular order. First, all nodes are positioned according to the content of their ``formula'' field, then once MathJax has finished this first typesetting, we can position the inference line and rule name. To position any side condition or text to the left of the inference line, we need to know the typeset width of the side condition text so we know how far to shift it to the left. To make this possible, we add the side condition to the page after the initial node positioning so that it will be typeset by MathJax, but we don't display it yet. Then once MathJax has run again, we can position the side condition properly.


\section{InfoVis Elements}
\label{sec:infoviselem}

Data in this visualization project are trees, so an important first consideration is determining a visual formalism for drawing trees that is consistent with conventions for this task. Herman et al.~\cite{graphvis-herman+melancon+marshall} discuss a number of techniques for visualizing trees. Several space saving representations are presented, such as H-tree layout, radial view, and balloon view. In \projectname{}, much of the utility of a proof tree comes from being able to read a flow of inferences, seeing the leaves as axioms or assumptions and the root as the conclusion of the proof. Each node contains a propositional formula, so to be readable all nodes need to have the same orientation.

The space-saving layouts could be useful if it is clear which node is the root and some other form of iconography could be used for constructing formulas. For the current project, we will use the Reingold and Tilford layout for trees, which could be described as visually rooted, since we have a convention that tells us which node we see as the root. We want to allow for inferences with more than two premises, so we need the version of the Reingold and Tilford algorithm extended by Walker to general trees~\cite{generaltreeslayout-walker}, then made more efficient to run in linear time by~\cite{improvingwalker-buchheim+etal}.

We will invert the standard tree constructed with this algorithm so that the root is at centre bottom as is conventional for drawing proof trees. The bottom center location of the root is a consistent position where we can find the goal of the proof, which is also the formula on the right side of a sequent, as described in section~\ref{sec:background}. Another benefit of the Reingold and Tilford algorithm for this application is the vertical alignment of nodes at the same level (distance from the root) in a proof. This permits a final difference between proof trees and general trees without making the relations between nodes unclear: we don't draw and links or edges between nodes. Instead, a horizontal line is drawn between a node and its children.

Focus+context techniques as discussed in~\cite{graphvis-herman+melancon+marshall} are naturally applied in \projectname{}. When we focus on a node, we maintain the context of the node in the tree as we can see its relation to nearby nodes. We emphasize the context by adjusting the colour of the children and parent of the focused node.

In~\cite[Chapter 3]{infovis-ware} we learn many best practices from Ware for using colour in a visualization. In \projectname{}, colour is used to highlight a selected node in a proof tree to bring the focus of the user to the current inference of interest. We also use colour to categorize nodes. Colour is preattentively processed, so as described in~\cite[Chapter 11]{infovis-ware} the user is able to have attention on spatially disconnected elements without each element being the current fixation. We use this property of attention to allow the user to attend to and distinguish between groups of nodes, such as previously visited nodes, future nodes, and the current focus.

Figueiras presents a taxonomy of interaction consisting of eleven categories of techniques~\cite{interaction-figueiras}. The categories of interaction used in this project are \textit{select} and \textit{overview/explore}.

A user may want to select data to learn more about it or track how it changes in response to other interaction. In \projectname{}, a node can be selected to see more detail on its role in the proof tree. Its related parent and child inferences can be highlighted, the rules used displayed, and the substitutions used in applying the rules explicitly stated.

Techniques in the overview/explore category first display an overview of the data, then allow exploration through zooming, filtering, and the display of details on demand. Large proof trees may sometimes escape the bounds of a monitor, so it may not be possible to have a full proof tree visible. Thus a proper ``overview'' is not guaranteed in all cases, but the full tree is available in the application, possibly requiring panning. The user can then explore the proof through the guided walk-through, seeing more details as the proof progresses and nodes are focused.

% Lin and Yang~\cite{readingcompgeometric-lin+yang} (TODO: check that used correct reference here) present five facets of proof comprehension: basic knowledge, logical status, summary, generality, and application. These facets are used to guide the design of this project. (TODO: read this... add more... lower priority than visual thinking content)

Yi et al. observe that sensemaking is one path to insight~\cite{insights-yi+etal}. Sensemaking, in the context of interactive visualizations, is an intentional process in which a person continually reframes their understanding of a concept. The authors also propose four processes for gaining insight: provide overview, adjust, detect pattern, and match mental model.

Provide overview means a user can gain a higher-level understanding of a data set. In \projectname{}, this is realized in the viewing of a complete proof tree.

Through adjust, a user is able to explore a data set. This can come from a variety of interaction techniques, such as adjustments to the level of abstraction, or selecting a range of values. In \projectname{}, the user can step through a proof using navigation arrows, causing updates to the selected node and supplementary proof guidance related to that node.

When new structure is observed in data and possibly new discoveries made, the user has been able to detect a pattern. In \projectname{}, examples of how this is realized include observing repeated arguments in a proof and being able to detect loops.

Match mental model means one has a bridge between the data and their mental model of it. Having an external visual version of the mental model allows for cognitive offloading. In this project, we will see the value of having a visualization of a proof to interact with rather than trying to hold the entire picture in one’s head. It is then possible to allocate more mental resources to reasoning and gaining insight through the other processes.


\section{Evaluation}
\label{sec:evaluation}

% from cognitive dimensions paper; low priority for this report, work on this once everything else is done
% review handouts from the class where this was discussed

Here we do a preliminary informal evaluation based on the author's experience in using \projectname{}.

On initial page load, the first example from the example selection menu is displayed. It may be better if initially there was no example to be displayed so that there is less information on the screen on load.

It would be useful for the user to have more guidance on how to start using the tool. Being initially presented with some instructions on how to get started is necessary. If the user is unfamiliar with proof trees, a pointer to a basic logic tutorial will be helpful.

It is possible that a user without any logic background could experiment by clicking on the nodes, reading the selection information, and see patterns between the concrete proof tree with the rules in the rules panel. This is an ideal use of the tool. We want users to learn about proofs through exploration.

If a user clicks on a non-root node during exploration, then all nodes that would have been visited earlier in the programmed traversal are coloured to be less visible. This might be confusing, since different traversals are possible and the user will not have experienced the full traversal up to this point. The multiple sudden changes may be distracting.

The proof walk-through is initiated by pressing the ``forward'' arrow in the top right. This highlights the root node. As discussed earlier, the currently programmed traversal is depth-first preorder. We are starting at the root of the tree which is the conclusion of the proof, and we reason in a backwards direction. In this situation, it is useful to have previously visited nodes made harder to read, so that the user is focused primarily on the current node, but can also see ahead in the walk-through. At the end of the walk-through, the forward button can be pressed, but the walkthrough does not go beyond having the last node in the traversal highlighted. This could be improved by having a more clear indication that traversal is done. The forward button could be unavailable, or the final node is coloured as the previously visited nodes.

It would be pleasant if there was a way to ``escape'' from having a node focused, so that there are no longer any nodes with special focus.

Overall, it is easy to explore proof trees and see supplementary information. The display is generally pleasant. There are many small changes that could substantially increase how useful this tool is in practice.

In the future we hope to perform a more detailed evaluation following the cognitive dimensions of Blackwell and Green~\cite{cogdim-blackwell+green}.

\section{Discussion}
\label{sec:discussion}

There are many decisions made in implementing and describing this project that the reader may wish to see motivated or explained further. We attempt to address these here. These extra discussions may be of interest to the curious reader but can be freely skipped.

In this paper we have used natural deduction as the example system when presenting the logic background and describing how to use the tool. In the current version of \projectname{}, most examples are natural deduction proofs. This logic was chosen because it is usually the first inference system presented in an introductory logic course, so it made sense as the system to use to make this paper readable to as wide an audience as reasonable. It also helped keep the presentation of background information manageable. A critical observation to make here is that there is nothing in the system that requires a user to commit to a single logic.

Since the tree data is a JSON object, the tree content can contain any string and thus be from any logic. An implication of this is that there is no check for correctness of the proof being displayed. In its current version, \projectname{} is only for visualization and not verification.

In the version of \projectname{} released with this paper, there is one example that is not a natural deduction proof. This is to illustrate the points just made. This example is a proof of $\Sigma ; P \vdash \exists M, \mathit{length} \; (1 :: 2 :: 3 :: [ \, ]) \; M$, a formalization of a Prolog query. Without being too pedantic, this query asks if there is an $M$ such that $M$ is the length of the list $(1 :: 2 :: 3 :: [\, ])$. The expression query above is the root node of the proof tree. In this example in the webpage we can see how this query is proven in Prolog and how the value of $M$ is computed to be 3.

A reader more familiar with, and favouring, the Martin-L{\"o}f approach to natural deduction may be wondering why we have not made an explicit distinction between formulas and judgments as in~\cite{natded-pfenning}. What we mean here is if we want to derive that formula $p$ is true, the node in the proof tree should say this explicitly, i.e., the node would contain the judgment $p \; \mathit{true}$. The current presentation has preferred the more condensed presentation where whenever we see a formula $p$ in a proof, we assume that this means $p$ is true. Aside from a smaller use of space, another benefit is we avoid the discussion of judgments vs formulas, making the presentation easier to digest for less experienced users and readers. As mentioned above, the experienced user could build a proof tree in this system where the judgment is clearly distinguished from the formula.

In \projectname{}, we have used a depth-first preorder traversal. A traversal had to be chosen to implement the proof walk-through and this choice of traversal felt intuitive to the author. If a user wishes to use a different traversal or it is found that another traversal would improve cognition in learning about proofs and logic, the change could be made fairly simply in the system. A two-way iterator was implemented to step forward or backward through the proof. This iterator accepts a callback representing a function to traverse a tree. This could either be updated only in the code, or a control could be added to the page so the user could select from a few traversal options.

Related to the traversal discussion, when we walked through an example in Section~\ref{sec:background}, we began with the root node. This backward reasoning is useful in automated reasoning, because we know we are starting with the root node and there is typically a finite set of rules that could have been used to infer that node (often only one rule). Starting with assumptions or leaves of the tree might feel more natural, because we start with what we know and work towards a goal. The issue with forward reasoning when constructing a tree is we don't know ahead of time what shape the tree will take and there is nothing in the shape of axioms or assumptions to guide our construction. So in building a proof without already knowing it, there is often a more algorithmic approach to the tree construction with backward reasoning than with forward. With all this said, in some logics (including natural deduction) backward reasoning alone is often not sufficiently intuitive, and in this case allowing the user to select different traversals would be useful.

\section{Future Work}
\label{sec:future}

There are many additions that could be made to this work to implement more lessons from the information visualization community and also to make the tool more useful for a range of proof-related tasks. We will first look at the updates in the InfoVis area.

Since large proof trees can escape the bounds of a digital display, navigation is another topic explored by Herman et al.~\cite{graphvis-herman+melancon+marshall} that is relevant to this project. The user will want to be able to scroll around the graph while exploring. The technique of incremental exploration and navigation can be used to display only a desired subtree of the proof; nodes will have an icon to either exclusively display or to hide the subtree that it is the root of.

Weber and Mejia-Ramos~\cite{majorsbeliefs-weber+mejiaramos} and Alcock and Wilkinson~\cite{eproofs-alcock+wilkinson} have argued that too much detail visible in a proof obscures high-level structural information which is important for proof comprehension. To address this concern, a future version will have two views for the proof display: detail view and structure view. Detail view will show a proof tree, possibly with subtrees hidden as discussed above, and with full formulas, rule names, and rule side conditions as presented in the rest of this paper. Structure view will show only the shape of the tree and which rules are used. % (TODO: graphic showing this)

The interaction technique abstract/elaborate presented by Yi et al.~\cite{interaction-yietal} and Figueiras~\cite{interaction-figueiras} is used to adjust the level of abstraction of the data. By including a separate structure view option as previously described, this tool will have an abstract view displaying the structure and an elaborate view displaying full proof detail.

The final InfoVis updates we propose involve the rules panel on the page. When selecting a node, there is supplementary information displayed below the tree, including the name of the rule used to derive the focused node. We would like to highlight the rule used to derive the focused node so that it is easier for the user to move their fixation to the rule being used and connect the children of the focused node with the premises of the rule. In the other direction, we would also like the user to be able to select a rule from the rules panel and have uses of this rule in the proof tree be highlighted.% (TODO: visual?).

Other updates would add more uses for the tool that are extraneous to information visualization. Once a proof is built, the user may want to present it in a \LaTeX{} document. It would be a small change to export the \LaTeX{} code for the tree from the JSON object representing the tree. Another helpful update is to add ``help'' information in the form of easily readable instructions on how to use the tool and a tutorial on natural deduction. A final modification would allow the user to also ``write'' the proofs using the tool.

In the current version of \projectname{}, there are a number of examples the user can choose to explore, but the tool would be far more useful if there was a way to add custom proofs. The best way for this to be done is to extend the interface so that new nodes can be added. Initial plans for this idea would add an icon to each node to add siblings, and another icon to each leaf node to make that node a result of an inference (i.e. add an inference line above), then children could be added above that node. The content of a new node would be entered in a text box and written in \LaTeX{}.% In this circumstance (better word?), the user is writing the proof, adding to ... (TODO: ref Duval work? Alcock?)

Once the project is updated to the point where a user can enter their own proof, it should also be a more pleasant experience than trying to write proof trees on paper. When writing a tree by hand on paper, you are more committed to the spatial position of the nodes you write; in \projectname{}, you will be able to easily modify the elements of the tree.

\section{Conclusion}
\label{sec:conclusion}

% \makeglossaries

In this paper we have seen how information visualization techniques can be used to make a tool for visualizing proof trees. Students studying logic in university will see proof trees during their studies. \projectname{} should help them gain confidence in using proof trees to construct logical arguments. Advanced users who write proofs in other formalisms, such as the Calculus of Constructions, or write logic program queries, may want to be able to be able to build a visual version of their proofs.

We presented the logical foundations necessary to understand how to use the \projectname{}. Following this, we saw how to use the tool, looking at each major area of the webpage, and reviewed the technologies used implementing the tool. Since this is an information visualization project, the InfoVis elements that helped guide the design are described. Finally, we attempted to address other concerns and questions that the reader might have and future modifications to the project.

It is our hope that this tool will be a useful resource for learning about formal reasoning. For more experienced users, we hope it will aid in the understanding of larger proofs in the proof-writing process and for documenting reasoning.


% TODO: motivation: logic is scary and intimidating for beginners? put this in conclusion?

% TODO: proof as argument \textit{obeying} logic rules \\


% (Interaction is an essential component of this project because it elevates a proof tree from a static graphic to a visualization that can lead to further understanding and insight along a variety of paths. Duval claims that proof trees are disappointing and visualizations in general do not lead to immediate comprehension in mathematics~\cite{repvisvis-duval}. It appears that what is meant by visualization in this article only includes static graphics representing mathematical objects. He also does not fully explore other advantages to explicit articulation of proof trees, such as cognitive offloading and observation of patterns in large proofs, which are particularly useful in proofs where the goal to be proven has a complicated logical structure. Here we propose that adding interaction to a proof tree will aid in understanding of both the logic used to build it and the proposition being proven, although this is stated without evidence and without a study to verify this hypothesis. There is more to discuss relating Duval’s work to what is being attempted here, and this will be expanded on in the final report.) (TODO: repetitive; bring some of these points to the conclusion? discussion?)

% Dump:
%
% (A formula in an inference rule represented by a symbol that is not one of the logical constants of the expression language is called a \textit{meta-variable}. For example, in the rule $\wedge_I$, the formulas $P_1$ and $P_2$ are meta-variables for the rule. To use rules in building a proof, we fill in meta-variables consistently and match the top-level symbols used when applying a sequence of rules. For example, the proof in Figure~\ref{fig:andcomm} shows that the connective $\wedge$ is commutative. (TODO: finish explanation of how rules used). If we can build a tree structure using the rules this way (TODO: expand) such that the leaves of the tree are the desired assumptions and the root is the desired goal, then we have built a \textit{proof tree}.) (TODO: move or remove?)



% \section{Temporary TODO}

% Terms for glossary or other special note:

% \begin{itemize}
%     \item proof
%     \item logic
%     \item formula
%     \item judgment
%     \item sequent
%     \item inference rule
%     \item proof tree
%     \item assumption (leaf in tree, left side of sequent)
%     \item premise (can be intermediate in rules; top of an inference)
%     \item hypothesis (hypothetical judgment)
%     \item goal vs conclusion
%     \item logical constant
% \end{itemize}


%\bibliographystyle{abbrv}
\bibliographystyle{abbrv-doi}
%\bibliographystyle{abbrv-doi-narrow}
%\bibliographystyle{abbrv-doi-hyperref}
%\bibliographystyle{abbrv-doi-hyperref-narrow}

\bibliography{visualanalytics_reportbib}
\end{document}

